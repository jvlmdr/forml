import Mathlib.Analysis.Distribution.SchwartzSpace
import Mathlib.Analysis.NormedSpace.BoundedLinearMaps
import Mathlib.Analysis.SpecialFunctions.ExpDeriv
import Mathlib.MeasureTheory.Integral.Bochner
import Mathlib.MeasureTheory.Integral.FundThmCalculus

-- https://github.com/leanprover/lean4/issues/2220
local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y)

open MeasureTheory SchwartzSpace

-- Define some handy `simp` lemmas for `1 + ‚Äñx‚Äñ`.
section OneAddNorm
variable {Œ± : Type*} [SeminormedAddGroup Œ±]

@[simp] lemma one_add_norm_pos (x : Œ±) : 0 < 1 + ‚Äñx‚Äñ :=
  add_pos_of_pos_of_nonneg zero_lt_one (norm_nonneg _)

@[simp] lemma one_add_norm_nonneg (x : Œ±) : 0 ‚â§ 1 + ‚Äñx‚Äñ :=
  le_of_lt (one_add_norm_pos x)

@[simp] lemma one_add_norm_ne_zero (x : Œ±) : 1 + ‚Äñx‚Äñ ‚â† 0 :=
  ne_of_gt (one_add_norm_pos x)

@[simp] lemma one_le_one_add_norm (x : Œ±) : 1 ‚â§ 1 + ‚Äñx‚Äñ :=
  le_add_of_nonneg_right (norm_nonneg _)

@[simp] lemma one_le_one_add_norm_pow_const (x : Œ±) (k : ‚Ñï) : 1 ‚â§ (1 + ‚Äñx‚Äñ) ^ k :=
  one_le_pow_of_one_le (one_le_one_add_norm x) k

@[simp] lemma one_add_norm_rpow_const_pos (x : Œ±) (r : ‚Ñù) : 0 < (1 + ‚Äñx‚Äñ) ^ r :=
  Real.rpow_pos_of_pos (one_add_norm_pos x) r

@[simp] lemma one_add_norm_rpow_const_nonneg (x : Œ±) (r : ‚Ñù) : 0 ‚â§ (1 + ‚Äñx‚Äñ) ^ r :=
  (one_add_norm_rpow_const_pos x r).le

end OneAddNorm


namespace SchwartzMap

variable {E F : Type*}
variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F]

@[simp]
lemma neg_apply {f : ùì¢(E, F)} {x : E} : (-f) x = -f x := rfl

end SchwartzMap


section Exponential

variable {E : Type*}
variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]

-- TODO: Would it make sense to provide this for `ùïú`-linearity?
/-- Analogy of `fderiv_exp` for complex exponential. -/
lemma fderiv_cexp_real {f : E ‚Üí ‚ÑÇ} {x : E} (hf : DifferentiableAt ‚Ñù f x) :
    fderiv ‚Ñù (fun x => Complex.exp (f x)) x = Complex.exp (f x) ‚Ä¢ fderiv ‚Ñù f x := by
  change fderiv ‚Ñù (Complex.exp ‚àò f) x = _
  rw [fderiv.comp x Complex.differentiable_exp.differentiableAt hf]
  rw [(Complex.hasStrictFDerivAt_exp_real (f x)).hasFDerivAt.fderiv]
  simp [ContinuousLinearMap.one_def]

end Exponential


section ContDiff

variable {ùïú ùïú' E F : Type*}
variable [NontriviallyNormedField ùïú]
variable [NormedAddCommGroup E] [NormedSpace ùïú E]
variable [NormedAddCommGroup F] [NormedSpace ùïú F]
variable [NontriviallyNormedField ùïú'] [NormedAlgebra ùïú ùïú'] [NormedSpace ùïú' F] [IsScalarTower ùïú ùïú' F]

lemma contDiff_smul_of_tower {n : ‚Ñï‚àû} : ContDiff ùïú n fun p : (ùïú' √ó F) => p.1 ‚Ä¢ p.2 :=
  isBoundedBilinearMap_smul.contDiff

lemma ContDiff.smul_of_tower {n : ‚Ñï‚àû} {f : E ‚Üí ùïú'} {g : E ‚Üí F} (hf : ContDiff ùïú n f) (hg : ContDiff ùïú n g) :
    ContDiff ùïú n fun x => f x ‚Ä¢ g x :=
  contDiff_smul_of_tower.comp (hf.prod hg)

end ContDiff


section IteratedFDeriv

variable {ùïú ùïú' E F : Type*}
variable [NontriviallyNormedField ùïú]
variable [NormedAddCommGroup E] [NormedSpace ùïú E]
variable [NormedAddCommGroup F] [NormedSpace ùïú F]
variable [Semiring ùïú'] [Module ùïú' F] [SMulCommClass ùïú ùïú' F] [ContinuousConstSMul ùïú' F]

-- Easier to use (issue with eta rewrite?).
lemma iteratedFDeriv_neg_apply' {x : E} {i : ‚Ñï} {f : E ‚Üí F} :
    iteratedFDeriv ùïú i (fun x => -f x) x = -iteratedFDeriv ùïú i f x := by
  rw [‚Üê iteratedFDeriv_neg_apply]
  rfl

-- Easier to use (issue with eta rewrite?).
lemma iteratedFDeriv_const_smul_apply' {i : ‚Ñï} {a : ùïú'} {f : E ‚Üí F} {x : E} (hf : ContDiff ùïú i f) :
    iteratedFDeriv ùïú i (fun x => a ‚Ä¢ f x) x = a ‚Ä¢ iteratedFDeriv ùïú i f x := by
  rw [‚Üê iteratedFDeriv_const_smul_apply hf]
  rfl

end IteratedFDeriv


section DerivComp

variable {ùïú ùïú' F : Type*}
variable [NontriviallyNormedField ùïú]
variable [NontriviallyNormedField ùïú'] [NormedAlgebra ùïú ùïú']
variable [NontriviallyNormedField F] [NormedAlgebra ùïú F] [NormedAlgebra ùïú' F]
variable [IsScalarTower ùïú ùïú' F]

lemma HasDerivAt.comp_of_tower (x : ùïú) {g : ùïú ‚Üí ùïú'} {f : ùïú' ‚Üí F} {g' : ùïú'} {f' : F}
    (hf : HasDerivAt f f' (g x))
    (hg : HasDerivAt g g' x) :
    HasDerivAt (fun x => f (g x)) (g' ‚Ä¢ f') x := by
  rw [hasDerivAt_iff_hasFDerivAt] at hf hg ‚ä¢
  refine HasFDerivAt.congr_fderiv (HasFDerivAt.comp x (hf.restrictScalars ùïú) hg) ?_
  refine ContinuousLinearMap.ext ?_
  intro m
  simp

lemma deriv.comp_of_tower (x : ùïú) {g : ùïú ‚Üí ùïú'} {f : ùïú' ‚Üí F}
    (hf : DifferentiableAt ùïú' f (g x))
    (hg : DifferentiableAt ùïú g x) :
    deriv (fun x => f (g x)) x = deriv g x ‚Ä¢ deriv f (g x) := by
  rw [‚Üê hasDerivAt_deriv_iff] at hf hg
  exact (HasDerivAt.comp_of_tower x hf hg).deriv

/-- Utility lemma as it can be easier to rewrite in `deriv` form. -/
lemma HasDerivAt.of_deriv (x : ùïú) {f : ùïú ‚Üí F} {f' : ùïú ‚Üí F} (h : DifferentiableAt ùïú f x) (h' : _root_.deriv f x = f' x) :
    HasDerivAt f (f' x) x := by
  rw [‚Üê h']
  exact h.hasDerivAt

/-- Utility lemma as it can be easier to rewrite in `deriv` form. -/
lemma HasDerivAt.comp_of_deriv (x : ùïú) {f : ùïú' ‚Üí F} {g : ùïú ‚Üí ùïú'} {fg' : ùïú ‚Üí F}
    (hf : DifferentiableAt ùïú f (g x))
    (hg : DifferentiableAt ùïú g x)
    (hf' : _root_.deriv (fun x => f (g x)) x = fg' x) :
    HasDerivAt (fun x => f (g x)) (fg' x) x := by
  rw [‚Üê hf']
  refine DifferentiableAt.hasDerivAt ?_
  exact DifferentiableAt.comp x hf hg

/-- Utility lemma as it can be easier to rewrite in `deriv` form. -/
lemma HasDerivAt.comp_of_deriv' (x : ùïú) {f : ùïú' ‚Üí F} {g : ùïú ‚Üí ùïú'} {fg' : ùïú ‚Üí F}
    (hf : DifferentiableAt ùïú' f (g x))
    (hg : DifferentiableAt ùïú g x)
    (hf' : _root_.deriv g x ‚Ä¢ _root_.deriv f (g x) = fg' x) :
    HasDerivAt (fun x => f (g x)) (fg' x) x := by
  rw [‚Üê hf']
  exact comp_of_tower x hf.hasDerivAt hg.hasDerivAt

end DerivComp


section Parts

variable {ùïú S E F G : Type*}
variable [NontriviallyNormedField ùïú]
variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [NormedSpace ùïú E]
variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [NormedSpace ùïú F]
variable [NormedAddCommGroup G] [NormedSpace ‚Ñù G] [NormedSpace ùïú G] [CompleteSpace G]
variable [NontriviallyNormedField S] [NormedSpace S G]
variable [NormedSpace ‚Ñù S] [SMulCommClass ‚Ñù S G] [IsScalarTower ‚Ñù S G]
variable [NormedSpace ùïú S] [SMulCommClass ùïú S G] [IsScalarTower ùïú S G]

lemma HasDerivAt.bilin {u : ùïú ‚Üí E} {u' : E} {v : ùïú ‚Üí F} {v' : F} (B : E ‚ÜíL[ùïú] F ‚ÜíL[ùïú] G) {x : ùïú}
    (hu : HasDerivAt u u' x) (hv : HasDerivAt v v' x) :
    HasDerivAt (fun x => B (u x) (v x)) (B u' (v x) + B (u x) v') x := by
  rw [hasDerivAt_iff_hasFDerivAt] at hu hv ‚ä¢
  refine (ContinuousLinearMap.hasFDerivAt_of_bilinear B hu hv).congr_fderiv ?_
  refine ContinuousLinearMap.ext ?_
  intro dx
  simp [ContinuousLinearMap.precompL]
  rw [add_comm]

lemma ContinuousOn.bilin {u : ùïú ‚Üí E} {v : ùïú ‚Üí F} {B : E ‚ÜíL[ùïú] F ‚ÜíL[ùïú] G} {s : Set ùïú}
    (hu : ContinuousOn u s) (hv : ContinuousOn v s) :
    ContinuousOn (fun x => B (u x) (v x)) s :=
  B.isBoundedBilinearMap.continuous.comp_continuousOn (hu.prod hv)

lemma Continuous.bilin {u : ùïú ‚Üí E} {v : ùïú ‚Üí F} {B : E ‚ÜíL[ùïú] F ‚ÜíL[ùïú] G}
    (hu : Continuous u) (hv : Continuous v) :
    Continuous (fun x => B (u x) (v x)) :=
  B.isBoundedBilinearMap.continuous.comp (hu.prod_mk hv)

section Def
variable (ùïú S G)

/-- Scalar multiplication for `IsScalarTower ùïú S G` as a `ùïú`-bilinear map. -/
noncomputable def ContinuousLinearMap.smulBilin : G ‚ÜíL[ùïú] S ‚ÜíL[ùïú] G :=
  LinearMap.mkContinuous‚ÇÇ
    { toFun := fun x => LinearMap.smulRight LinearMap.id x,
      map_add' := fun x y => by simp; ext m; simp,
      map_smul' := fun c x => by simp; ext m; simp; rw [‚Üê smul_comm]}
    1 (fun x c => by simp [norm_smul]; rw [mul_comm])

end Def

section Explicit
variable (ùïú)

@[simp]
lemma ContinuousLinearMap.smulBilin_apply {x : G} {c : S} : smulBilin ùïú S G x c = c ‚Ä¢ x := rfl

-- Can be used to rewrite scalar multiplication as application of a bilinear CLM.
lemma ContinuousLinearMap.flip_smulBilin_apply {x : G} {c : S} : (smulBilin ùïú S G).flip c x = c ‚Ä¢ x := rfl

end Explicit

/-- `smulBilin` with `S = k` is equal to `smulRightL id`. -/
lemma ContinuousLinearMap.smulRightL_id_eq_smulBilin :
    smulBilin ùïú ùïú G = (smulRightL ùïú ùïú G) (id ùïú ùïú) := rfl

/-- `smulRight` can be rewritten as composition with `smulBilin`. -/
lemma ContinuousLinearMap.smulRight_eq_smulBilin_comp {c : G ‚ÜíL[ùïú] S} {x : G} :
    smulRight c x = (smulBilin ùïú S G x).comp c := rfl

/-- Scalar multiplication of a `ContinuousLinearMap` can be rewritten as composition with `smulBilin`. -/
lemma ContinuousLinearMap.smul_clm_eq_smulBilin_flip_comp {c : S} {f : G ‚ÜíL[ùïú] G} :
    c ‚Ä¢ f = ((smulBilin ùïú S G).flip c).comp f := rfl

/--
Integration by parts for a general bilinear map.

TODO: Might be possible to relax `ContinuousOn` to `IntervalIntegrable` if there exists a lemma
which is analogous to `IntervalIntegrable.mul_continuousOn` for bilinear CLMs.
-/
theorem intervalIntegral.integral_deriv_bilin_eq_sub {u u' : ‚Ñù ‚Üí E} {v v' : ‚Ñù ‚Üí F} (B : E ‚ÜíL[‚Ñù] F ‚ÜíL[‚Ñù] G)
    (hu : ‚àÄ x ‚àà Set.uIcc a b, HasDerivAt u (u' x) x)
    (hv : ‚àÄ x ‚àà Set.uIcc a b, HasDerivAt v (v' x) x)
    (hu' : ContinuousOn u' (Set.uIcc a b))
    (hv' : ContinuousOn v' (Set.uIcc a b)) :
    ‚à´ x in a..b, B (u' x) (v x) + B (u x) (v' x) = B (u b) (v b) - B (u a) (v a) := by
  refine integral_eq_sub_of_hasDerivAt (fun x hx => HasDerivAt.bilin B (hu x hx) (hv x hx)) ?_
  refine (ContinuousOn.add ?_ ?_).intervalIntegrable
  . exact ContinuousOn.bilin hu' (HasDerivAt.continuousOn hv)
  . exact ContinuousOn.bilin (HasDerivAt.continuousOn hu) hv'

/--
Integration by parts for a general bilinear map.

This must use `‚Ñù`-linearity because `u` and `v` are differentiable functions on `‚Ñù`.
-/
theorem intervalIntegral.integral_bilin_deriv_eq_deriv_bilin {u u' : ‚Ñù ‚Üí E} {v v' : ‚Ñù ‚Üí F} (B : E ‚ÜíL[‚Ñù] F ‚ÜíL[‚Ñù] G)
    (hu : ‚àÄ x ‚àà Set.uIcc a b, HasDerivAt u (u' x) x)
    (hv : ‚àÄ x ‚àà Set.uIcc a b, HasDerivAt v (v' x) x)
    (hu' : ContinuousOn u' (Set.uIcc a b))
    (hv' : ContinuousOn v' (Set.uIcc a b)) :
    ‚à´ x in a..b, B (u x) (v' x) = B (u b) (v b) - B (u a) (v a) - ‚à´ x in a..b, B (u' x) (v x) := by
  rw [‚Üê integral_deriv_bilin_eq_sub B hu hv hu' hv']
  rw [‚Üê integral_sub]
  ¬∑ simp
  . refine (ContinuousOn.add ?_ ?_).intervalIntegrable
    . exact ContinuousOn.bilin hu' (HasDerivAt.continuousOn hv)
    . exact ContinuousOn.bilin (HasDerivAt.continuousOn hu) hv'
  ¬∑ exact (ContinuousOn.bilin hu' (HasDerivAt.continuousOn hv)).intervalIntegrable

/-- Integration by parts for smul. -/
lemma intervalIntegral.integral_deriv_smul_eq_sub {u u' : ‚Ñù ‚Üí S} {v v' : ‚Ñù ‚Üí G}
    (hu : ‚àÄ x ‚àà Set.uIcc a b, HasDerivAt u (u' x) x)
    (hv : ‚àÄ x ‚àà Set.uIcc a b, HasDerivAt v (v' x) x)
    (hu' : ContinuousOn u' (Set.uIcc a b))
    (hv' : ContinuousOn v' (Set.uIcc a b)) :
    ‚à´ x in a..b, u' x ‚Ä¢ v x + u x ‚Ä¢ v' x = u b ‚Ä¢ v b - u a ‚Ä¢ v a :=
  integral_deriv_bilin_eq_sub (ContinuousLinearMap.smulBilin ‚Ñù S G).flip hu hv hu' hv'

/-- Integration by parts for smul. -/
theorem intervalIntegral.integral_smul_deriv_eq_deriv_smul {u u' : ‚Ñù ‚Üí S} {v v' : ‚Ñù ‚Üí G}
    (hu : ‚àÄ x ‚àà Set.uIcc a b, HasDerivAt u (u' x) x)
    (hv : ‚àÄ x ‚àà Set.uIcc a b, HasDerivAt v (v' x) x)
    (hu' : ContinuousOn u' (Set.uIcc a b))
    (hv' : ContinuousOn v' (Set.uIcc a b)) :
    ‚à´ x in a..b, u x ‚Ä¢ v' x = u b ‚Ä¢ v b - u a ‚Ä¢ v a - ‚à´ x in a..b, u' x ‚Ä¢ v x :=
  integral_bilin_deriv_eq_deriv_bilin (ContinuousLinearMap.smulBilin ‚Ñù S G).flip hu hv hu' hv'

end Parts


section LinearInner

variable {ùïú : Type*} [IsROrC ùïú] {E : Type*} [NormedAddCommGroup E] [InnerProductSpace ùïú E]

variable (ùïú)

theorem norm_innerSL_le_one : ‚ÄñinnerSL ùïú (E := E)‚Äñ ‚â§ 1 := by
  simp [ContinuousLinearMap.op_norm_le_iff]

end LinearInner
