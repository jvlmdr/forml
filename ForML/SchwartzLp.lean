-- First prove that Schwartz maps have finite integral.
-- This can be achieved by proving that Schwartz maps are in `Lp`.

-- Then prove that integral is a continuous linear map `ùì¢(E, F) ‚ÜíL[ùïú] F`.
-- To achieve this, define conversion from `ùì¢(E, F)` to `Lp F 1` as CLM.
-- This lets us use `ContinuousLinearMap.comp` to convert
-- a CLMs on `Lp F 1` to a CLM on `ùì¢(E, F)`, including `L1.integralCLM`.

-- TODO: Prove that Schwartz maps are dense in Lp.

import Mathlib.Analysis.Distribution.SchwartzSpace
import Mathlib.Analysis.SpecialFunctions.JapaneseBracket
import Mathlib.MeasureTheory.Function.L1Space
import Mathlib.MeasureTheory.Integral.Bochner

import ForML.Util

-- https://github.com/leanprover/lean4/issues/2220
local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y)

open MeasureTheory SchwartzSpace

-- Eventual goal: Prove that Fourier transform of Dirac is const and vice versa.

-- Want to define tempered distribution for constant function.
-- This corresponds to the integral of the function multiplied by a constant.
-- Therefore, need to prove that `SchartzMap` is integrable.
--
-- Use equivalent definition of Schwartz functions as described in:
-- https://math.stackexchange.com/questions/1505921/schwartz-functions-have-finite-lp-norm

-- Couldn't find this in mathlib.
lemma ENNReal_rpow_ne_top {a : ENNReal} {p : ‚Ñù} (hp : 0 < p) (h : a ‚â† ‚ä§) : a ^ p ‚â† ‚ä§ := by
  rw [‚Üê ENNReal.ofReal_toReal_eq_iff] at h
  rw [‚Üê h]
  simp
  intros
  exact hp.le

lemma ENNReal_rpow_lt_top {a : ENNReal} {p : ‚Ñù} (hp : 0 < p) (h : a < ‚ä§) : a ^ p < ‚ä§ := by
  rw [lt_top_iff_ne_top] at h ‚ä¢
  exact ENNReal_rpow_ne_top hp h


namespace SchwartzMap

variable {E F : Type*}
variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F]

lemma coeFn_add {f g : ùì¢(E, F)} : (‚Üë(f + g) : E ‚Üí F) = ‚Üëf + ‚Üëg := by
  ext x
  simp

/- Exposes alternative form of Schwartz decay condition.

Can be obtained from `one_add_le_sup_seminorm_apply`.
Useful for combining with "Japanese bracket" in `integrable_one_add_norm`.

TODO: Add proof of equivalence of conditions?
TODO: Check if this is more simply obtained with
`le_rpow_one_add_norm_iff_norm_le` and `SchwartzMap.norm_pow_mul_le_seminorm`?
-/
lemma decay‚ÇÅ (f : ùì¢(E, F)) :
    ‚àÄ (k n : ‚Ñï), ‚àÉ C, ‚àÄ x, (1 + ‚Äñx‚Äñ) ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ C := by
  intro k n
  have := @one_add_le_sup_seminorm_apply ‚Ñù E F _ _ _ _ _ _ _ ‚ü®k, n‚ü© k n (by simp) (by simp) f
  simp at this
  use ((2 : ‚Ñù) ^ k) * Finset.sup (Finset.Iic (k, n)) (fun m => SchwartzMap.seminorm ‚Ñù m.1 m.2) f


-- Trivial but may be useful for definitions.
lemma decay_of_decay‚ÇÅ {f : E ‚Üí F}
    (h : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, (1 + ‚Äñx‚Äñ) ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ C) :
    ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ C := by
  intro k n
  specialize h k n
  rcases h with ‚ü®C, hC‚ü©
  use C
  intro x
  specialize hC x
  refine le_trans ?_ hC
  refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)
  simp [pow_le_pow_of_le_left]

/- Re-arranged version of `decay‚ÇÅ`. -/
lemma norm_iteratedFDeriv_le_pow_one_add_norm (f : ùì¢(E, F)) (r : ‚Ñù) :
    ‚àÄ (n : ‚Ñï), ‚àÉ C, 0 ‚â§ C ‚àß ‚àÄ x, ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ C * (1 + ‚Äñx‚Äñ) ^ (-r) := by
  -- TODO: Better to remove the negative in the power?
  -- Most interesting for non-negative powers.
  intro n
  -- Use any integer `k` such that `r ‚â§ k`.
  generalize hk : ‚åàr‚åâ‚Çä = k
  rcases decay‚ÇÅ f k n with ‚ü®C, hC‚ü©
  use C
  refine And.intro ?_ ?_
  . specialize hC 0  -- Use any `E`.
    simp at hC
    exact le_trans (norm_nonneg _) hC
  . intro x
    specialize hC x
    have h_pos : 0 < 1 + ‚Äñx‚Äñ := add_pos_of_pos_of_nonneg zero_lt_one (norm_nonneg _)
    rw [Real.rpow_neg h_pos.le]
    rw [mul_comm, inv_mul_eq_div]
    rw [le_div_iff' (Real.rpow_pos_of_pos h_pos _)]
    refine le_trans ?_ hC
    refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)
    rw [‚Üê Real.rpow_nat_cast]
    refine Real.rpow_le_rpow_of_exponent_le (by simp) ?_
    simp [‚Üê hk]
    exact Nat.le_ceil _

/- Useful form for proving that derivatives are in `Lp`. -/
lemma pow_norm_iteratedFDeriv_le_pow_one_add_norm (f : ùì¢(E, F)) {p : ‚Ñù} (hp : 0 < p) (q : ‚Ñù) :
    ‚àÄ (n : ‚Ñï), ‚àÉ C, 0 ‚â§ C ‚àß ‚àÄ x, ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ^ p ‚â§ C * (1 + ‚Äñx‚Äñ) ^ (-q) := by
  -- Seems wild that we can choose arbitrary `q`?
  intro n
  generalize hr : q / p = r
  rcases norm_iteratedFDeriv_le_pow_one_add_norm f r n with ‚ü®C, ‚ü®hC_nonneg, hC‚ü©‚ü©
  use C ^ p
  have hC_pow : 0 ‚â§ C ^ p := Real.rpow_nonneg_of_nonneg hC_nonneg _
  refine And.intro hC_pow ?_
  intro x
  specialize hC x
  have hq : q = p * r := by rw [‚Üê hr, mul_div, mul_div_cancel_left _ hp.ne']
  rw [hq]
  have hb_pos : 0 < 1 + ‚Äñx‚Äñ
  . exact add_pos_of_pos_of_nonneg zero_lt_one (norm_nonneg _)
  rw [mul_comm p r, ‚Üê neg_mul, Real.rpow_mul hb_pos.le]
  rw [‚Üê Real.mul_rpow hC_nonneg (Real.rpow_nonneg_of_nonneg hb_pos.le _)]
  exact Real.rpow_le_rpow (norm_nonneg _) hC hp.le

/- Simple version of `pow_norm_iteratedFDeriv_le_pow_one_add_norm` with `q = -1`. -/
lemma pow_norm_iteratedFDeriv_le_inv_one_add_norm (f : ùì¢(E, F)) {p : ‚Ñù} (hp : 0 < p) :
    ‚àÄ (n : ‚Ñï), ‚àÉ C, 0 ‚â§ C ‚àß ‚àÄ x, ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ^ p ‚â§ C * (1 + ‚Äñx‚Äñ)‚Åª¬π := by
  have := pow_norm_iteratedFDeriv_le_pow_one_add_norm f hp 1
  simpa [Real.rpow_neg_one]

-- Rewrite for `norm` (`iteratedFDeriv` with `n = 0`).

/- Convenient form of `pow_norm_iteratedFDeriv_le_pow_one_add_norm`. -/
lemma pow_norm_le_pow_one_add_norm (f : ùì¢(E, F)) {p : ‚Ñù} (hp : 0 < p) (q : ‚Ñù) :
    ‚àÉ C, 0 ‚â§ C ‚àß ‚àÄ x, ‚Äñf x‚Äñ ^ p ‚â§ C * (1 + ‚Äñx‚Äñ) ^ (-q) := by
  have := pow_norm_iteratedFDeriv_le_pow_one_add_norm f hp q 0
  simpa

/- Schwartz map is bounded by `C_q * (1 + ‚Äñx‚Äñ) ^ (-q)` for all `q`. -/
lemma norm_le_pow_one_add_norm (f : ùì¢(E, F)) (q : ‚Ñù) :
    ‚àÉ C, 0 ‚â§ C ‚àß ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C * (1 + ‚Äñx‚Äñ) ^ (-q) := by
  have := pow_norm_iteratedFDeriv_le_pow_one_add_norm f zero_lt_one q 0
  simpa

/- Convenient form of `pow_norm_iteratedFDeriv_le_pow_one_add_norm`. -/
lemma pow_norm_le_inv_one_add_norm (f : ùì¢(E, F)) {p : ‚Ñù} (hp : 0 < p) :
    ‚àÉ C, 0 ‚â§ C ‚àß ‚àÄ x, ‚Äñf x‚Äñ ^ p ‚â§ C * (1 + ‚Äñx‚Äñ)‚Åª¬π := by
  have := pow_norm_iteratedFDeriv_le_inv_one_add_norm f hp 0
  simpa

/- Schwartz map is bounded by `C * (1 + ‚Äñx‚Äñ)‚Åª¬π`. -/
lemma norm_le_inv_one_add_norm (f : ùì¢(E, F)) :
    ‚àÉ C, 0 ‚â§ C ‚àß ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C * (1 + ‚Äñx‚Äñ)‚Åª¬π := by
  have := pow_norm_iteratedFDeriv_le_inv_one_add_norm f zero_lt_one 0
  simpa


section Integrable

variable [mE : MeasureSpace E]
variable [FiniteDimensional ‚Ñù E] [BorelSpace E] [mE.volume.IsAddHaarMeasure]

-- Simple to prove `L‚àû` case.
lemma snorm_top_lt_top (f : ùì¢(E, F)) : snorm f ‚ä§ volume < ‚ä§ := by
  rcases f.decay 0 0 with ‚ü®C, hC‚ü©
  simp at hC
  exact snormEssSup_lt_top_of_ae_bound (Filter.eventually_of_forall hC.right)

-- lemma nnnorm_rpow_real_of_nonneg {x : ‚Ñù} (hx : 0 ‚â§ x) {r : ‚Ñù} : ‚Äñx ^ r‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä ^ r := by
--   ext
--   simp
--   exact Real.abs_rpow_of_nonneg hx

/-- More general version of `snorm_nnreal_lt_top`. -/
lemma snorm_nnreal_one_add_norm_rpow_smul_lt_top (n : ‚Ñù) (f : ùì¢(E, F)) {p : NNReal} (hp : 0 < p) :
    snorm (fun x => (1 + ‚Äñx‚Äñ) ^ n ‚Ä¢ f x) p volume < ‚ä§ := by
  simp [snorm, hp.ne', snorm']
  refine ENNReal_rpow_lt_top (inv_pos_of_pos hp) ?_
  generalize hr : (FiniteDimensional.finrank ‚Ñù E + 1 : ‚Ñù) = r
  -- Need to get `C` for condition.
  rcases pow_norm_le_pow_one_add_norm f hp (r + n * p) with ‚ü®C, ‚ü®hC_nonneg, hC‚ü©‚ü©
  simp at hC
  suffices : ‚à´‚Åª (x : E), (‚Äñ(1 + ‚Äñx‚Äñ) ^ n ‚Ä¢ f x‚Äñ‚Çä : ENNReal) ^ (p : ‚Ñù) ‚â§ ‚à´‚Åª (x : E), ENNReal.ofReal (C * (1 + ‚Äñx‚Äñ) ^ (-r))
  . refine lt_of_le_of_lt this ?_
    -- Remove the `C` from the condition.
    simp_rw [ENNReal.ofReal_mul hC_nonneg]
    rw [lintegral_const_mul]
    swap
    . refine Measurable.ennreal_ofReal ?_
      exact Measurable.pow_const (Measurable.const_add measurable_norm _) _
    refine ENNReal.mul_lt_top (by simp) ?_
    -- Use the "Japanese bracket".
    rw [‚Üê lt_top_iff_ne_top]
    refine finite_integral_one_add_norm ?_
    simp [‚Üê hr]
  refine lintegral_mono ?_
  intro x
  specialize hC x
  simp
  -- Get to NNReal.
  rw [ENNReal.ofReal]
  rw [ENNReal.coe_rpow_of_nonneg _ p.coe_nonneg]
  norm_cast
  -- Get to ‚Ñù.
  rw [‚Üê norm_toNNReal]
  simp [‚Üê Real.toNNReal_rpow_of_nonneg, norm_nonneg]
  refine Real.toNNReal_le_toNNReal ?_
  -- Show inequality.
  -- TODO: Uses simp lemmas in Util. Feels a bit sloppy?
  simp [norm_smul]
  rw [Real.mul_rpow (by simp) (by simp)]
  rw [abs_of_nonneg (by simp)]
  rw [‚Üê Real.rpow_mul (by simp)]
  rw [‚Üê le_div_iff' (by simp)]
  refine le_of_le_of_eq hC ?_
  rw [Real.rpow_add (by simp)]
  rw [mul_div_assoc, div_eq_inv_mul]
  rw [Real.rpow_neg]
  simp

lemma integrable_one_add_norm_rpow_smul {n : ‚Ñù} {f : ùì¢(E, F)} : Integrable fun x => (1 + ‚Äñx‚Äñ) ^ n ‚Ä¢ f x := by
  refine And.intro ?_ ?_
  . refine AEStronglyMeasurable.smul ?_ f.continuous.aestronglyMeasurable
    refine (AEMeasurable.pow_const ?_ n).aestronglyMeasurable
    exact (continuous_const.add continuous_norm).aemeasurable
  . rw [HasFiniteIntegral]
    rw [‚Üê snorm_one_eq_lintegral_nnnorm]
    exact snorm_nnreal_one_add_norm_rpow_smul_lt_top n f zero_lt_one

lemma integrable_norm_pow_smul {n : ‚Ñï} {f : ùì¢(E, F)} : Integrable fun x => ‚Äñx‚Äñ ^ n ‚Ä¢ f x := by
  refine And.intro ?_ ?_
  . refine AEStronglyMeasurable.smul ?_ f.continuous.aestronglyMeasurable
    refine (AEMeasurable.pow_const ?_ n).aestronglyMeasurable
    exact measurable_norm.aemeasurable
  . rw [HasFiniteIntegral]
    rw [‚Üê snorm_one_eq_lintegral_nnnorm]
    refine lt_of_le_of_lt ?_ (snorm_nnreal_one_add_norm_rpow_smul_lt_top n f zero_lt_one)
    refine snorm_mono ?_
    intro x
    simp [norm_smul]
    refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg (f x))
    rw [abs_of_nonneg (by simp)]
    refine pow_le_pow_of_le_left ?_ ?_ _ <;> simp

lemma integrable_norm_pow_mul_norm {n : ‚Ñï} {f : ùì¢(E, F)} : Integrable fun x => ‚Äñx‚Äñ ^ n * ‚Äñf x‚Äñ := by
  refine And.intro ?_ ?_
  . refine AEStronglyMeasurable.mul ?_ f.continuous.norm.aestronglyMeasurable
    refine (AEMeasurable.pow_const ?_ n).aestronglyMeasurable
    exact measurable_norm.aemeasurable
  . rw [HasFiniteIntegral]
    rw [‚Üê snorm_one_eq_lintegral_nnnorm]
    refine lt_of_le_of_lt ?_ (snorm_nnreal_one_add_norm_rpow_smul_lt_top n f zero_lt_one)
    refine snorm_mono ?_
    intro x
    simp [norm_smul]
    refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg (f x))
    rw [abs_of_nonneg (by simp)]
    refine pow_le_pow_of_le_left ?_ ?_ _ <;> simp

/--
Schwartz maps in `ùì¢(E, F)` are in `Lp` for `p ‚àà (0, ‚àû)` and finite-dimensional `E`.

Only holds for `volume` (inherited from `integrable_one_add_norm`).
-/
lemma snorm_nnreal_lt_top (f : ùì¢(E, F)) {p : NNReal} (hp : 0 < p) : snorm f p volume < ‚ä§ := by
  simpa using snorm_nnreal_one_add_norm_rpow_smul_lt_top 0 f hp

lemma snorm_lt_top (f : ùì¢(E, F)) {p : ENNReal} : snorm f p volume < ‚ä§ := by
  cases p with
  | none => exact snorm_top_lt_top f
  | some p =>
    simp
    cases eq_or_lt_of_le (zero_le p) with
    | inl hp => simp [‚Üê hp]
    | inr hp => exact snorm_nnreal_lt_top f hp

/- Schwartz maps in `ùì¢(E, F)` are in `Lp` for finite-dimensional `E`.

TODO: Show that Schwartz maps are dense in `Lp`?
Might be achieved by showing that smooth, compact functions are dense in `Lp`.
-/
lemma mem‚Ñíp (f : ùì¢(E, F)) (p : ENNReal) : Mem‚Ñíp f p :=
  ‚ü®f.continuous.aestronglyMeasurable, (snorm_lt_top f)‚ü©

-- def toLp (p : ENNReal) (f : ùì¢(E, F)) : Lp (Œ± := E) F p :=
--   Mem‚Ñíp.toLp f (mem‚Ñíp f p)

-- This gives us a bit more for free.
def addHomLp (p : ENNReal) : ùì¢(E, F) ‚Üí+ Lp (Œ± := E) F p where
  toFun f := Mem‚Ñíp.toLp f (mem‚Ñíp f p)
  map_zero' := rfl
  map_add' _ _ := rfl

def toLp (p : ENNReal) (f : ùì¢(E, F)) : Lp (Œ± := E) F p := addHomLp p f

example (p : ENNReal) (f : ùì¢(E, F)) : toLp p (-f) = -toLp p f := rfl

lemma coeFn_toLp {p : ENNReal} (f : ùì¢(E, F)) : f.toLp p =·µê[volume] f :=
  Mem‚Ñíp.coeFn_toLp (mem‚Ñíp f p)

-- `L1` is useful for `L1.integralCLM`.
-- Also, any function in `L1` is also in `Lp` with `1 < p`.
noncomputable def toL1 : ùì¢(E, F) ‚Üí Lp (Œ± := E) F 1 := toLp 1

lemma coeFn_toL1 (f : ùì¢(E, F)) : f.toL1 =·µê[volume] f := by simp [toL1, coeFn_toLp]

lemma norm_toL1_eq_integral (f : ùì¢(E, F)) : ‚ÄñtoL1 f‚Äñ = ‚à´ x, ‚Äñf x‚Äñ := by
  simp [toL1, toLp, addHomLp]
  rw [snorm_one_eq_lintegral_nnnorm]
  rw [integral_norm_eq_lintegral_nnnorm f.continuous.aestronglyMeasurable]

-- Use `Mem‚Ñíp f 1` to provide `Integrable`.
lemma integrable (f : ùì¢(E, F)) : Integrable (fun x => f x) := by
  rw [‚Üê mem‚Ñíp_one_iff_integrable]
  exact mem‚Ñíp f 1

-- Use `Mem‚Ñíp f ‚àû` to give bound on norm.
lemma bound (f : ùì¢(E, F)) : ‚àÄ x : E, ‚Äñf x‚Äñ ‚â§ ‚Äñf.toBoundedContinuousFunction‚Äñ := by
  exact BoundedContinuousFunction.norm_coe_le_norm (toBoundedContinuousFunction f)


section ToL1

variable {ùïú : Type*} [NormedField ùïú] -- Don't need `NontriviallyNormedField ùïú`.
variable [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]

-- Write a short version of the supremem of the seminorm over `Finset.Iic (k, n)`.
-- `k` is the power, `n` is the derivative number.
-- TODO: Avoid notation of `ùïú k`?
section Def
variable (ùïú)
noncomputable def sup_Iic_seminorm (k n : ‚Ñï) : ùì¢(E, F) ‚Üí ‚Ñù :=
  fun f => (Finset.Iic (k, n)).sup (schwartzSeminormFamily ùïú E F) f
end Def

lemma sup_Iic_seminorm_apply {k n : ‚Ñï} {f : ùì¢(E, F)} :
  sup_Iic_seminorm ùïú k n f = (Finset.Iic (k, n)).sup (schwartzSeminormFamily ùïú E F) f := rfl

-- Now we need to obtain an upper bound of the form:
-- `‚àÉ C, ‚à´ x, ‚Äñf x‚Äñ ‚â§ C * sup_Iic_seminorm ùïú k n f`
-- for some `k` and `n` that we choose.

-- Obtain inequality relating `‚Äñf x‚Äñ` and `sup_Iic_seminorm ùïú k 0 f` (i.e. 0-th derivative).
lemma pow_one_add_norm_mul_norm_le_two_pow_sup_Iic_seminorm (k : ‚Ñï) (f : ùì¢(E, F)) (x : E) :
    (1 + ‚Äñx‚Äñ) ^ k * ‚Äñf x‚Äñ ‚â§ ‚Üë2 ^ k * sup_Iic_seminorm ùïú k 0 f := by
  have := @one_add_le_sup_seminorm_apply ùïú E F _ _ _ _ _ _ _ (k, 0) k 0
  simp at this
  specialize this f x
  simpa

section Explicit
variable (ùïú)  -- Only appears on one side of inequality.
lemma pow_norm_mul_norm_le_two_pow_sup_Iic_seminorm {k : ‚Ñï} {f : ùì¢(E, F)} (x : E) :
    ‚Äñx‚Äñ ^ k * ‚Äñf x‚Äñ ‚â§ ‚Üë2 ^ k * sup_Iic_seminorm ùïú k 0 f := by
  refine le_trans ?_ (pow_one_add_norm_mul_norm_le_two_pow_sup_Iic_seminorm k f x)
  refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)
  refine pow_le_pow_of_le_left ?_ ?_ k <;> simp
end Explicit

-- Re-arrange as upper bound of a function by a function.
-- TODO: Eliminate this lemma? It's trivial and not that useful.
lemma norm_le_sup_Iic_seminorm_mul_one_add_norm_pow_neg (k : ‚Ñï) (f : ùì¢(E, F)) (x : E) :
    ‚Äñf x‚Äñ ‚â§ ‚Üë2 ^ k * sup_Iic_seminorm ùïú k 0 f * (1 + ‚Äñx‚Äñ) ^ (-k : ‚Ñù) := by
  simp [Real.rpow_neg]
  rw [mul_comm, inv_mul_eq_div]
  simp [le_div_iff']
  have : (1 + ‚Äñx‚Äñ) ^ k * ‚Äñf x‚Äñ ‚â§ ‚Üë2 ^ k * sup_Iic_seminorm ùïú k 0 f
  . refine pow_one_add_norm_mul_norm_le_two_pow_sup_Iic_seminorm k f x
  simpa

-- Prove that bound exists for any finite-dimensional `E`.
-- TODO: Remove dependence on `SchwartzMap.integrable`?
lemma integral_norm_le_const_mul_sup_Iic_seminorm
    {r : ‚Ñï} (hr : FiniteDimensional.finrank ‚Ñù E < r) (f : ùì¢(E, F)) :
    ‚à´ x, ‚Äñf x‚Äñ ‚â§ (‚Üë2 ^ r * ‚à´ (x : E), (1 + ‚Äñx‚Äñ) ^ (-r : ‚Ñù)) * sup_Iic_seminorm ùïú r 0 f := by
  have h_int : Integrable (fun (x : E) => (1 + ‚Äñx‚Äñ) ^ (-r : ‚Ñù))
  . refine integrable_one_add_norm ?_
    norm_cast
  conv => rhs; rw [mul_assoc]; rhs; rw [mul_comm]
  rw [‚Üê mul_assoc]
  rw [‚Üê integral_mul_left]
  refine integral_mono f.integrable.norm (h_int.const_mul _) ?_
  intro x
  simp
  exact norm_le_sup_Iic_seminorm_mul_one_add_norm_pow_neg r f x

lemma toL1_add (œÜ Œ∏ : ùì¢(E, F)) : (œÜ + Œ∏).toL1 = œÜ.toL1 + Œ∏.toL1 := by rfl
lemma toL1_smul (c : ùïú) (œÜ : ùì¢(E, F)) : (c ‚Ä¢ œÜ).toL1 = c ‚Ä¢ œÜ.toL1 := by rfl

-- Prove that map from `ùì¢(E, F)` to `Lp F p` is continuous.
-- TODO: Generalize to Lp?
-- TODO: Extract (and generalize?) the proof of continuity?
section Def
variable (ùïú)
noncomputable def toL1_CLM' : ùì¢(E, F) ‚ÜíL[ùïú] Lp (Œ± := E) F 1 where
  toLinearMap := ‚ü®‚ü®toL1, toL1_add‚ü©, toL1_smul‚ü©
  cont := by
    refine Seminorm.cont_withSeminorms_normedSpace _ (schwartz_withSeminorms ùïú E F) _ ?_
    simp [Seminorm.le_def]
    conv => arg 1; intro s; arg 1; intro C; intro œÜ  -- Rename.
    simp [NNReal.smul_def]
    generalize hk : FiniteDimensional.finrank ‚Ñù E + 1 = k
    use Finset.Iic ‚ü®k, 0‚ü©
    have hC : (0 : ‚Ñù) ‚â§ ‚Üë2 ^ k * ‚à´ (x : E), (1 + ‚Äñx‚Äñ) ^ (-k : ‚Ñù)
    . simp
      refine integral_nonneg ?_
      intro x
      simp [Real.rpow_neg]
    use ‚ü®_, hC‚ü©
    simp
    intro f
    rw [norm_toL1_eq_integral]
    rw [‚Üê sup_Iic_seminorm]
    refine integral_norm_le_const_mul_sup_Iic_seminorm ?_ _
    simp [‚Üê hk]
end Def

noncomputable def toL1_CLM : ùì¢(E, F) ‚ÜíL[‚Ñù] Lp (Œ± := E) F 1 := toL1_CLM' ‚Ñù

end ToL1


section Integral

variable {ùïú ùïú' : Type*}
-- Provide variants of integral maps that are `ùïú`-linear.
variable [NontriviallyNormedField ùïú]
variable [CompleteSpace F]
variable [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]

section Def
variable (ùïú)
/- The integral of a Schwartz map as a continuous linear map. -/
noncomputable def integralCLM' : ùì¢(E, F) ‚ÜíL[ùïú] F :=
  ContinuousLinearMap.comp (L1.integralCLM' ùïú) (toL1_CLM' ùïú)
end Def

lemma integralCLM'_apply {f : ùì¢(E, F)} :
    integralCLM' ùïú f = ‚à´ x, f x := by
  rw [MeasureTheory.integral_eq _ f.integrable]
  rw [integralCLM', L1.integral_def]
  rfl

/- The integral of a Schwartz map as a continuous linear map. -/
noncomputable def integralCLM : ùì¢(E, F) ‚ÜíL[‚Ñù] F := integralCLM' ‚Ñù

lemma integralCLM_apply {f : ùì¢(E, F)} : integralCLM f = ‚à´ x, f x := by
  rw [integralCLM]
  exact integralCLM'_apply

lemma integralCLM_neg_apply {f : ùì¢(E, F)} : integralCLM (-f) = -(integralCLM f) := by
  rw [ContinuousLinearMap.map_neg]
  -- simp [integralCLM_apply]

lemma integralCLM_smul_apply
    {ùïú : Type*} [NontriviallyNormedField ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]
    {c : ùïú} {f : ùì¢(E, F)} : integralCLM (c ‚Ä¢ f) = c ‚Ä¢ (integralCLM f) := by
  -- rw [ContinuousLinearMap.map_smul integralCLM c f]
  -- rw [ContinuousLinearMap.map_smul_of_tower integralCLM c f]
  simp [integralCLM_apply, integral_smul]


namespace Distribution

-- For distributions, only consider `‚Ñù`-linearity.
-- Provide scalar multiplication with `ùïú'`.
variable [NormedField ùïú'] [NormedSpace ‚Ñù ùïú']
variable [NormedSpace ùïú' F] [SMulCommClass ‚Ñù ùïú' F] [IsScalarTower ‚Ñù ùïú' F]

noncomputable instance instOne : One (ùì¢(E, F) ‚ÜíL[‚Ñù] F) where
  one := SchwartzMap.integralCLM

lemma one_apply {œÜ : ùì¢(E, F)} : (1 : ùì¢(E, F) ‚ÜíL[‚Ñù] F) œÜ = ‚à´ x, œÜ x := by
  change (One.one : ùì¢(E, F) ‚ÜíL[‚Ñù] F) œÜ = _
  simp [One.one]
  rw [integralCLM_apply]

section Def
variable (E F)
noncomputable def const (c : ùïú') : ùì¢(E, F) ‚ÜíL[‚Ñù] F := c ‚Ä¢ (1 : ùì¢(E, F) ‚ÜíL[‚Ñù] F)
end Def

lemma const_apply {c : ùïú'} {œÜ : ùì¢(E, F)} : const E F c œÜ = c ‚Ä¢ ‚à´ x, œÜ x := by
  simp [const, one_apply]

noncomputable instance instNatCast : NatCast (ùì¢(E, F) ‚ÜíL[‚Ñù] F) where
  natCast n := const E F (n : ‚Ñù)

noncomputable instance instIntCast : IntCast (ùì¢(E, F) ‚ÜíL[‚Ñù] F) where
  intCast n := const E F (n : ‚Ñù)

end Distribution  -- namespace

end Integral
end Integrable

end SchwartzMap  -- namespace
