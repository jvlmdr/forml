import Mathlib.Algebra.BigOperators.Basic
import Mathlib.Data.Nat.Choose.Multinomial

import ForML.Multichoose

open scoped BigOperators

attribute [simp] Fin.succ_ne_zero


namespace Finset

variable {Œπ Œ∫ : Type*}

-- TODO: Is this the most natural choice? Better to use `MapsTo` and... inverse?
-- TODO: Add product and sum together?
/-- Convenient form of `Finset.sum_nbij` using composition with the inverse. -/
lemma sum_bijOn_comp_leftInv {E : Type*} [AddCommMonoid E]
    {s : Finset Œπ} {t : Finset Œ∫} {f : Œπ ‚Üí E} {e : Œπ ‚Üí Œ∫} {e' : Œ∫ ‚Üí Œπ}
    (he : Set.BijOn e s t) (he' : Set.LeftInvOn e' e s) :
    ‚àë i in s, f i = ‚àë i in t, f (e' i) :=
  sum_nbij (i := e) (fun _ hx ‚Ü¶ he.1 hx) he.2.1 he.2.2 (fun _ hx ‚Ü¶ congrArg f (he' hx).symm)

end Finset

variable {Œ± : Type*} [DecidableEq Œ±]
variable {Œ≤ : Type*} [DecidableEq Œ≤]

namespace Multiset

@[simp]
lemma multinomial_zero : multinomial (0 : Multiset Œ±) = 1 := rfl

theorem card_filter_ne (a : Œ±) (s : Multiset Œ±) :
    card (s.filter (fun x => x ‚â† a)) = card s - s.count a := by
  conv => rhs; lhs; rw [‚Üê Multiset.filter_add_not (fun x => x = a) s]
  simp only [_root_.map_add, count_eq_card_filter_eq, ne_eq, eq_comm (a := a)]
  rw [Nat.add_sub_cancel_left]

end Multiset

namespace Prod

def mkFstEmbedding (b : Œ≤) : Œ± ‚Ü™ Œ± √ó Œ≤ := ‚ü®fun x ‚Ü¶ (x, b), by simp [Function.Injective]‚ü©
def mkSndEmbedding (a : Œ±) : Œ≤ ‚Ü™ Œ± √ó Œ≤ := ‚ü®fun x ‚Ü¶ (a, x), by simp [Function.Injective]‚ü©

@[simp] lemma mkFstEmbedding_apply (b : Œ≤) (x : Œ±) : mkFstEmbedding b x = (x, b) := rfl
@[simp] lemma mkSndEmbedding_apply (a : Œ±) (x : Œ≤) : mkSndEmbedding a x = (a, x) := rfl

end Prod

-- lemma Multiset.multinomial_eq {m : Multiset Œ±} : m.multinomial = Nat.multinomial m.toFinset m.count := by
--   simp [Multiset.multinomial, Finsupp.multinomial_eq]
--   rfl

variable {E : Type*}  -- TODO: Rename/remove?

-- `[CommMonoid A]` for `Finset.prod`
-- `[NormedRing A] [NormedAlgebra ùïú A]` to be like `norm_iteratedFDeriv_mul_le`
variable {A : Type*} [CommSemiring A]  -- CommMonoid?


section Split

namespace Finset

-- TODO: Would it be better to use `Fin k.succ √ó Multiset Œ±`?
/--
Image of count-cons-remove on `Finset.multichoose k s`, defined as a `Finset`.
Equivalent to `{q : ‚Ñï √ó Multiset (Fin n) | q.1 ‚â§ k ‚àß q.2 ‚àà Finset.multichoose (k - q.1) Finset.univ}`.
-/
def multichooseSplit (k : ‚Ñï) (s : Finset Œ±) (x : Œ±) : Finset (‚Ñï √ó Multiset Œ±) :=
  (range k.succ).biUnion fun m ‚Ü¶ (multichoose (k - m) (s.erase x)).map (Prod.mkSndEmbedding m)

-- TODO: Add proof of image.

theorem mem_multichooseSplit_iff {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} {q : ‚Ñï √ó Multiset Œ±} :
    q ‚àà multichooseSplit k s x ‚Üî q.1 ‚â§ k ‚àß q.2 ‚àà multichoose (k - q.1) (s.erase x) := by
  rcases q with ‚ü®m, t‚ü©
  simp [multichooseSplit, Nat.lt_succ]

/-- Helper lemma for `multichooseSplitEquiv`. -/
theorem consCountFilterNe_mem_multichooseSplit {k : ‚Ñï} {s : Finset Œ±} {x : Œ±}
    {t : Multiset Œ±} (ht : t ‚àà multichoose k s) :
    (Multiset.count x t, Multiset.filter (fun a => a ‚â† x) t) ‚àà multichooseSplit k s x := by
  rw [mem_multichoose_iff] at ht
  rcases ht with ‚ü®ht_card, ht_mem‚ü©
  simp only [‚Üê ht_card]
  refine mem_multichooseSplit_iff.mpr (And.intro ?_ ?_)
  ¬∑ exact Multiset.count_le_card x t
  ¬∑ refine mem_multichoose_iff.mpr (And.intro ?_ ?_)
    ¬∑ rw [‚Üê Multiset.card_filter_ne]
    ¬∑ simp only [Multiset.mem_filter, mem_erase, and_imp]
      intro a ha
      simp [ht_mem a ha]

/-- Helper lemma for `multichooseSplitEquiv`. -/
theorem replicateAdd_mem_multichoose {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} (hx : x ‚àà s)
    {q : ‚Ñï √ó Multiset Œ±} (hq : q ‚àà multichooseSplit k s x) :
    Multiset.replicate q.1 x + q.2 ‚àà multichoose k s := by
  rcases q with ‚ü®m, t‚ü©
  simp only [mem_multichooseSplit_iff, mem_multichoose_iff] at hq
  rcases hq with ‚ü®hm, ht_card, ht_mem‚ü©
  refine mem_multichoose_iff.mpr (And.intro ?_ ?_)
  ¬∑ simp [ht_card, hm]
  ¬∑ intro a ha
    simp only [Multiset.mem_add, Multiset.mem_replicate] at ha
    cases ha with
    | inl ha => rw [ha.2]; exact hx
    | inr ha => exact mem_of_mem_erase (ht_mem a ha)


theorem mapsTo_consCountFilterNe_multichoose {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} :
    Set.MapsTo (fun t ‚Ü¶ (Multiset.count x t, Multiset.filter (fun a => a ‚â† x) t))
      (multichoose k s) (multichooseSplit k s x) :=
  fun _ ht ‚Ü¶ consCountFilterNe_mem_multichooseSplit ht

theorem mapsTo_replicateAdd_multichooseSplit {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} (hx : x ‚àà s) :
    Set.MapsTo (fun q : ‚Ñï √ó Multiset Œ± ‚Ü¶ Multiset.replicate q.1 x + q.2)
      (multichooseSplit k s x) (multichoose k s) :=
  fun _ hq ‚Ü¶ replicateAdd_mem_multichoose hx hq

theorem leftInvOn_consCountFilterNe_multichoose {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} :
    Set.LeftInvOn (fun q ‚Ü¶ Multiset.replicate q.1 x + q.2)
      (fun t ‚Ü¶ (Multiset.count x t, Multiset.filter (fun a => a ‚â† x) t))
      (multichoose k s) := by
  simp [Set.LeftInvOn, ‚Üê Multiset.filter_eq', Multiset.filter_add_not]

theorem leftInvOn_replicateAdd_multichooseSplit {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} :
    Set.LeftInvOn (fun t ‚Ü¶ (Multiset.count x t, Multiset.filter (fun a => a ‚â† x) t))
      (fun q ‚Ü¶ Multiset.replicate q.1 x + q.2)
      (multichooseSplit k s x) := by
  rw [Set.LeftInvOn]
  intro q
  rcases q with ‚ü®m, t‚ü©
  simp only [mem_coe, mem_multichooseSplit_iff, mem_multichoose_iff, and_imp]
  intro _ _ ht_mem
  refine Prod.mk.inj_iff.mpr (And.intro ?_ ?_)
  ¬∑ rw [Multiset.count_add, Multiset.count_replicate_self]
    rw [add_right_eq_self, Multiset.count_eq_zero]
    intro hxt
    exact not_mem_erase x s (ht_mem x hxt)
  ¬∑ rw [Multiset.filter_add]
    rw [Multiset.filter_eq_nil.mpr (by simp [Multiset.mem_replicate])]
    rw [Multiset.filter_eq_self.mpr (fun a ha ‚Ü¶ ne_of_mem_erase (ht_mem a ha))]
    simp

-- Combine `LeftInvOn` and `MapsTo` to obtain `injOn`, `surjOn`, `bijOn`.

theorem injOn_consCountFilterNe_multichoose {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} :
    Set.InjOn (fun t ‚Ü¶ (Multiset.count x t, Multiset.filter (fun a => a ‚â† x) t))
      (multichoose k s) :=
  leftInvOn_consCountFilterNe_multichoose.injOn

theorem injOn_replicateAdd_multichooseSplit {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} :
    Set.InjOn (fun q : ‚Ñï √ó Multiset Œ± ‚Ü¶ Multiset.replicate q.1 x + q.2)
      (multichooseSplit k s x) :=
  leftInvOn_replicateAdd_multichooseSplit.injOn

theorem surjOn_consCountFilterNe_multichoose {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} (hx : x ‚àà s) :
    Set.SurjOn (fun t ‚Ü¶ (Multiset.count x t, Multiset.filter (fun a => a ‚â† x) t))
      (multichoose k s) (multichooseSplit k s x) :=
  leftInvOn_replicateAdd_multichooseSplit.surjOn (mapsTo_replicateAdd_multichooseSplit hx)

theorem surjOn_replicateAdd_multichooseSplit {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} :
    Set.SurjOn (fun q : ‚Ñï √ó Multiset Œ± ‚Ü¶ Multiset.replicate q.1 x + q.2)
      (multichooseSplit k s x) (multichoose k s) :=
  leftInvOn_consCountFilterNe_multichoose.surjOn (mapsTo_consCountFilterNe_multichoose)

theorem bijOn_consCountFilterNe_multichoose {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} (hx : x ‚àà s) :
    Set.BijOn (fun t ‚Ü¶ (Multiset.count x t, Multiset.filter (fun a => a ‚â† x) t))
      (multichoose k s) (multichooseSplit k s x) :=
  ‚ü®mapsTo_consCountFilterNe_multichoose,
    ‚ü®injOn_consCountFilterNe_multichoose, surjOn_consCountFilterNe_multichoose hx‚ü©‚ü©

theorem bijOn_addReplicate_multichooseSplit {k : ‚Ñï} {s : Finset Œ±} {x : Œ±} (hx : x ‚àà s) :
    Set.BijOn (fun q : ‚Ñï √ó Multiset Œ± ‚Ü¶ Multiset.replicate q.1 x + q.2)
      (multichooseSplit k s x) (multichoose k s) :=
  ‚ü®mapsTo_replicateAdd_multichooseSplit hx,
    ‚ü®injOn_replicateAdd_multichooseSplit, surjOn_replicateAdd_multichooseSplit‚ü©‚ü©

-- TODO: `multichoose_eq_biUnion_multichoose_erase`

-- def multichooseSplitEquiv (k : ‚Ñï) {s : Finset Œ±} {x : Œ±} (hx : x ‚àà s) :
--     ‚Üë(multichoose k s) ‚âÉ ‚Üë(multichooseSplit k s x) where
--   toFun
--     | ‚ü®t, ht‚ü© => ‚ü®‚ü®t.count x, t.filter (fun a ‚Ü¶ a ‚â† x)‚ü©, consCountFilterNe_mem_multichooseSplit ht‚ü©
--   invFun
--     | ‚ü®q, hq‚ü© => ‚ü®Multiset.replicate q.1 x + q.2, replicateAdd_mem_multichoose hx hq‚ü©
--   left_inv := by
--     simp [Function.LeftInverse, ‚Üê Multiset.filter_eq', Multiset.filter_add_not]
--   right_inv := by
--     simp only [Function.RightInverse, Function.LeftInverse, Subtype.forall, Subtype.mk.injEq]
--     intro q
--     rcases q with ‚ü®m, t‚ü©
--     simp only [mem_multichooseSplit_iff, mem_multichoose_iff, and_imp]
--     intro _ _ ht_mem
--     refine Prod.mk.inj_iff.mpr (And.intro ?_ ?_)
--     ¬∑ rw [Multiset.count_add, Multiset.count_replicate_self]
--       rw [add_right_eq_self, Multiset.count_eq_zero]
--       intro hxt
--       exact not_mem_erase x s (ht_mem x hxt)
--     ¬∑ rw [Multiset.filter_add]
--       rw [Multiset.filter_eq_nil.mpr (by simp [Multiset.mem_replicate])]
--       rw [Multiset.filter_eq_self.mpr (fun a ha ‚Ü¶ ne_of_mem_erase (ht_mem a ha))]
--       simp

-- @[simp]
-- lemma apply_multichooseSplitEquiv (k : ‚Ñï) {s : Finset Œ±} {x : Œ±} (hx : x ‚àà s)
--     (t : multichoose k s) :
--     (multichooseSplitEquiv k hx t).val = (t.val.count x, t.val.filter (fun a ‚Ü¶ a ‚â† x)) := rfl

-- @[simp]
-- lemma apply_multichooseSplitEquiv_symm (k : ‚Ñï) {s : Finset Œ±} {x : Œ±} (hx : x ‚àà s)
--     (q : multichooseSplit k s x) :
--     ((multichooseSplitEquiv k hx).symm q).val = Multiset.replicate q.val.fst x + q.val.snd := rfl

lemma pairwiseDisjoint_multichooseSplit (k : ‚Ñï) (s : Finset Œ±) (x : Œ±) :
    Set.PairwiseDisjoint ‚Üë(range (Nat.succ k))
      fun m ‚Ü¶ ((s.erase x).multichoose (k - m)).map (Prod.mkSndEmbedding m) := by
  intro i _ j _ hij
  simp [disjoint_iff_ne, hij]

end Finset  -- namespace
end Split

namespace Finset

theorem pow_sum {p : ‚Ñï} {s : Finset Œ±} {f : Œ± ‚Üí A} :
    (‚àë i in s, f i) ^ p = ‚àë k in s.multichoose p, k.multinomial * ‚àè i in s, f i ^ k.count i := by
  induction s using Finset.induction generalizing p with
  | empty => cases p <;> simp
  | @insert a s ha ih =>
    -- Apply binomial theorem on left.
    rw [Finset.sum_insert ha, add_pow]
    -- Re-index sum on right.
    rw [sum_bijOn_comp_leftInv (bijOn_consCountFilterNe_multichoose (mem_insert_self a s))
      leftInvOn_consCountFilterNe_multichoose]
    rw [multichooseSplit]
    rw [sum_biUnion (pairwiseDisjoint_multichooseSplit p _ a)]
    refine Finset.sum_congr rfl ?_
    simp only [mem_range, Nat.lt_succ]
    intro m hmp
    -- Apply inductive hypothesis on left.
    simp only [ih, Finset.mul_sum, Finset.sum_mul]
    -- Simplify inner sum on right.
    simp only [sum_map, erase_insert ha, Prod.mkSndEmbedding_apply]
    refine Finset.sum_congr rfl ?_
    intro t ht
    -- Separate the multinomial and product terms.
    suffices : (Multiset.replicate m a + t).multinomial = p.choose m * t.multinomial ‚àß
        ‚àè i in insert a s, f i ^ (Multiset.replicate m a + t).count i = f a ^ m * ‚àè i in s, f i ^ t.count i
    ¬∑ rw [this.1, this.2, Nat.cast_mul]
      ring_nf
    rw [Finset.mem_multichoose_iff] at ht
    -- `s` is a disjoint union of `t` and `{a}`.
    have hat : a ‚àâ t := fun h ‚Ü¶ ha (ht.2 a h)
    have hs_ne : ‚àÄ i ‚àà s, i ‚â† a := fun i his hia ‚Ü¶ by rw [hia] at his; exact ha his
    refine And.intro ?_ ?_
    ¬∑ -- Split the multinomial term.
      rw [Multiset.multinomial_filter_ne a]
      refine congrArg‚ÇÇ _ ?_ ?_
      ¬∑ simp [ht.1, hmp, hat]
      ¬∑ rw [Multiset.filter_add]
        simp only [ne_comm (a := a), Multiset.filter_add]
        rw [Multiset.filter_eq_nil.mpr (by simp [Multiset.mem_replicate])]
        rw [Multiset.filter_eq_self.mpr (fun u hu ‚Ü¶ ne_of_mem_of_not_mem hu hat)]
        rw [zero_add]
    ¬∑ -- Split the product.
      rw [Finset.prod_insert ha]
      refine congrArg‚ÇÇ _ ?_ (Finset.prod_congr rfl ?_)
      ¬∑ simp [hat]
      ¬∑ intro i hi
        simp [Multiset.count_replicate, hs_ne i hi]

end Finset
