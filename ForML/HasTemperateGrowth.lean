import Mathlib.Analysis.Distribution.SchwartzSpace
import Mathlib.Analysis.Fourier.FourierTransform
import Mathlib.Analysis.SpecialFunctions.ExpDeriv
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv

import ForML.Util

-- https://github.com/leanprover/lean4/issues/2220
local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y)

open scoped Real Complex SchwartzSpace BigOperators

section Basic

variable {E F G : Type*}
variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F]

lemma Function.HasTemperateGrowth.differentiable {g : E ‚Üí F} (hg : Function.HasTemperateGrowth g) :
    Differentiable ‚Ñù g :=  hg.1.differentiable le_top

/-- Any constant function is a trivial example of `HasTemperateGrowth`. -/
lemma Function.hasTemperateGrowth_const {c : F} : Function.HasTemperateGrowth (fun (_ : E) => c) := by
  refine ‚ü®contDiff_const, ?_‚ü©
  intro n
  cases n with
  | zero => refine ‚ü®0, ‚Äñc‚Äñ, ?_‚ü©; simp
  | succ n => refine ‚ü®0, 0, ?_‚ü©; simp [iteratedFDeriv_const_of_ne, Nat.succ_ne_zero]

/-- Any Schwartz function is a trivial example of `HasTemperateGrowth`. -/
lemma SchwartzMap.hasTemperateGrowth (f : ùì¢(E, F)) : Function.HasTemperateGrowth f := by
  refine ‚ü®f.smooth', ?_‚ü©
  intro n
  have hf_decay := f.decay' 0 n
  rcases hf_decay with ‚ü®C, hC‚ü©
  simp at hC
  refine ‚ü®0, C, ?_‚ü©
  simpa

-- Require `Nontrivial` for `ContinuousLinearMap.norm_id`.
section Explicit
variable (E)
lemma Function.hasTemperateGrowth_id [Nontrivial E] : Function.HasTemperateGrowth (id : E ‚Üí E) := by
  refine ‚ü®contDiff_id, ?_‚ü©
  intro n
  refine ‚ü®1, 1, ?_‚ü©
  intro x
  simp
  cases n with
  | zero => simp
  | succ n =>
    cases n <;> simp [iteratedFDeriv_succ_eq_comp_right]
end Explicit

/-- Any `ContinuousLinearMap` is a `HasTemperateGrowth` function. -/
lemma Function.HasTemperateGrowth.clm [Nontrivial E] {a : E ‚ÜíL[‚Ñù] F} : Function.HasTemperateGrowth fun x => a x := by
  constructor
  . exact ContDiff.clm_apply contDiff_const contDiff_id
  . intro n
    refine ‚ü®1, ‚Äña‚Äñ, ?_‚ü©
    intro x
    refine le_trans (norm_iteratedFDeriv_clm_apply contDiff_const contDiff_id _ le_top) ?_
    -- Only need to consider first term.
    rw [add_comm n 1]
    rw [Finset.sum_range_add]
    simp
    rw [Finset.sum_eq_zero ?_]
    swap
    . intro i _
      rw [iteratedFDeriv_const_of_ne] <;> simp
    simp
    refine mul_le_mul_of_nonneg_left ?_ (norm_nonneg _)
    -- TODO: Could re-use result of `hasTemperateGrowth_id`?
    cases n with
    | zero => simp
    | succ n =>
      simp [iteratedFDeriv_succ_eq_comp_right]
      cases n with
      | zero => simp
      | succ n =>
        rw [iteratedFDeriv_const_of_ne] <;> simp

lemma Real.hasTemperateGrowth_mul_left {a : ‚Ñù} : Function.HasTemperateGrowth fun x : ‚Ñù => a * x := by
  constructor
  . refine ContDiff.mul contDiff_const contDiff_id
  . intro n
    refine ‚ü®1, |a|, ?_‚ü©
    intro x
    simp
    cases n with
    | zero => simp [mul_add]
    | succ n =>
      simp [iteratedFDeriv_succ_eq_comp_right]
      simp_rw [fderiv_const_mul differentiableAt_id']
      simp
      cases n with
      | zero =>
        simp
        refine le_trans (norm_smul_le _ _) ?_
        simp [mul_add]
        refine mul_nonneg (by simp) (by simp)
      | succ n =>
        rw [iteratedFDeriv_const_of_ne (by simp)]
        simp
        refine mul_nonneg (by simp) ?_
        exact add_nonneg (by simp) (by simp)

end Basic


section Differentiable

variable {ùïú : Type*} [NontriviallyNormedField ùïú]
variable {ùïú' : Type*} [NontriviallyNormedField ùïú'] [NormedAlgebra ùïú ùïú'] [NormedSpace ùïú' ‚ÑÇ]
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E]
-- `NormedAlgebra` instead of `NormedSpace` for `Complex.differentiable_exp`
variable [NormedAlgebra ùïú ‚ÑÇ] [IsScalarTower ùïú ùïú' ‚ÑÇ]

lemma Differentiable.cexp_smul_I {f : E ‚Üí ùïú'} (hf : Differentiable ùïú f) :
    Differentiable ùïú fun x => Complex.exp (f x ‚Ä¢ (I : ‚ÑÇ)) :=
  Complex.differentiable_exp.comp (hf.smul_const I)

lemma Complex.differentiable_exp_real_smul_I : Differentiable ‚Ñù (fun x : ‚Ñù => exp (x ‚Ä¢ I)) :=
  Differentiable.cexp_smul_I differentiable_id

end Differentiable


section IteratedDeriv
-- Some useful lemmata for `iteratedDeriv` that avoid passing through `iteratedFDeriv`.
-- TODO: Typeclasses might not be perfect; some trial and error involved.

variable {ùïú : Type*} [NontriviallyNormedField ùïú] [NormedSpace ùïú ‚ÑÇ]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ùïú F]
variable {ùïú' : Type*} [NormedField ùïú'] [NormedSpace ùïú' ‚ÑÇ]
variable [NormedAlgebra ùïú ùïú'] [IsScalarTower ùïú ùïú' ‚ÑÇ]

lemma iteratedDeriv_neg_apply {n : ‚Ñï} {f : ùïú ‚Üí F} :
    iteratedDeriv n (fun x => -f x) x = -iteratedDeriv n f x := by
  change iteratedDeriv n (-f) x = _
  simp only [iteratedDeriv_eq_iteratedFDeriv]
  simp [iteratedFDeriv_neg_apply]

lemma iteratedDeriv_const_mul_apply {n : ‚Ñï} (a : ùïú') {f : ùïú ‚Üí ùïú'} (hf : ContDiff ùïú n f) {x : ùïú} :
    iteratedDeriv n (fun x => a * f x) x = a * iteratedDeriv n f x := by
  change iteratedDeriv n (a ‚Ä¢ f) x = _
  simp only [iteratedDeriv_eq_iteratedFDeriv]
  simp [iteratedFDeriv_const_smul_apply hf]

lemma iteratedDeriv_mul_const_apply {n : ‚Ñï} (a : ùïú') {f : ùïú ‚Üí ùïú'} (hf : ContDiff ùïú n f) {x : ùïú} :
    iteratedDeriv n (fun x => f x * a) x = iteratedDeriv n f x * a := by
  simp_rw [mul_comm _ a]
  exact iteratedDeriv_const_mul_apply a hf

end IteratedDeriv


section Util

variable {E F : Type*}
variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F]

/-- Convenient lemma for bounding `choose` sums. -/
lemma Finset.sum_range_choose_smul_le_pow_two_smul {Œ± : Type*} [OrderedAddCommMonoid Œ±] [OrderedSMul ‚Ñï Œ±]
    {n : ‚Ñï} {f : ‚Ñï ‚Üí Œ±} {B : Œ±} (h : ‚àÄ i ‚àà Finset.range (n + 1), f i ‚â§ B) :
    ‚àë i in Finset.range (n + 1), n.choose i ‚Ä¢ f i ‚â§ 2 ^ n ‚Ä¢ B := by
  rw [‚Üê Nat.sum_range_choose]
  rw [Finset.sum_smul]
  refine Finset.sum_le_sum ?_
  intro i hi
  exact smul_le_smul_of_nonneg (h i hi) (Nat.zero_le _)

-- TODO: Rename/move this?
-- TODO: Maybe there is machinery in BigO to do this?
/-- Take maximum `k` and maximum `C` to obtain bounding monomial for all `i < n`. -/
lemma bound_forall_range (n : ‚Ñï) {f : ‚Ñï ‚Üí E ‚Üí ‚Ñù}
    (h : ‚àÄ i, i < n ‚Üí ‚àÉ (k : ‚Ñï) (C : ‚Ñù), ‚àÄ x, f i x ‚â§ C * (1 + ‚Äñx‚Äñ) ^ k) :
    ‚àÉ (k : ‚Ñï) (C : ‚Ñù), 0 ‚â§ C ‚àß ‚àÄ i, i < n ‚Üí ‚àÄ x, f i x ‚â§ C * (1 + ‚Äñx‚Äñ) ^ k := by
  induction n with
  | zero => simp; use 0
  | succ n h_ind =>
    specialize h_ind ?_  -- Feels like we shouldn't have to do this?
    . intro i hi
      refine h _ ?_
      exact lt_trans hi (Nat.lt_succ_self _)
    specialize h n (Nat.lt_succ_self _)
    rcases h with ‚ü®k_m, C_m, hC_m‚ü©
    rcases h_ind with ‚ü®k_i, C_i, ‚ü®hC_i_nonneg, hC_i‚ü©‚ü©
    refine ‚ü®max k_i k_m, max C_i C_m, ?_‚ü©
    refine And.intro (le_trans hC_i_nonneg (by simp)) ?_
    intro i hi x
    simp [Nat.lt_succ] at hi
    cases lt_or_eq_of_le hi with
    | inl hi =>
      specialize hC_i i hi x
      refine le_trans hC_i ?_
      refine mul_le_mul ?_ (pow_le_pow ?_ ?_) ?_ (le_trans hC_i_nonneg ?_) <;> simp
    | inr hi =>
      rw [hi]
      specialize hC_m x
      refine le_trans hC_m ?_
      refine mul_le_mul ?_ (pow_le_pow ?_ ?_) ?_ (le_trans hC_i_nonneg ?_) <;> simp

/-- Take maximum `k` and maximum `C` to obtain bound on derivatives of `g` for all `i < n`. -/
lemma Function.HasTemperateGrowth.bound_forall_range (n : ‚Ñï) {f : E ‚Üí F} (hf : HasTemperateGrowth f) :
    ‚àÉ k C, 0 ‚â§ C ‚àß ‚àÄ i ‚àà Finset.range n, ‚àÄ (x : E), ‚ÄñiteratedFDeriv ‚Ñù i f x‚Äñ ‚â§ C * (1 + ‚Äñx‚Äñ) ^ k := by
  simp
  refine _root_.bound_forall_range n ?_
  intro i _
  exact hf.2 i

/-- The Fr√©chet derivative of a `HasTemperateGrowth` function is a `HasTemperateGrowth` function. -/
lemma Function.HasTemperateGrowth.fderiv {f : E ‚Üí F} (hf : HasTemperateGrowth f) :
    HasTemperateGrowth (fun x => fderiv ‚Ñù f x) := by
  refine ‚ü®hf.1.fderiv_right le_top, ?_‚ü©
  intro n
  rcases bound_forall_range (n + 2) hf with ‚ü®k, C, ‚ü®_, hC‚ü©‚ü©
  refine ‚ü®k, C, ?_‚ü©
  intro x
  suffices : ‚ÄñiteratedFDeriv ‚Ñù (n + 1) (fun x => f x) x‚Äñ ‚â§ C * (1 + ‚Äñx‚Äñ) ^ k
  . simpa [iteratedFDeriv_succ_eq_comp_right] using this
  refine hC (n + 1) ?_ x
  exact Finset.self_mem_range_succ (n + 1)

end Util


section Compose

variable {E F G : Type*}
variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
variable [NormedAddCommGroup G] [NormedSpace ‚Ñù G]

-- TODO: Could this be more easily proved using BigO?
/-- The composition of two `HasTemperateGrowth` functions is a `HasTemperateGrowth` function. -/
theorem Function.HasTemperateGrowth.comp
      {g : F ‚Üí G} (hg : HasTemperateGrowth g)
      {f : E ‚Üí F} (hf : HasTemperateGrowth f) :
    Function.HasTemperateGrowth fun x => g (f x) := by
  refine ‚ü®ContDiff.comp hg.1 hf.1, ?_‚ü©
  intro n
  -- Obtain `k, C` for derivatives of `g` and `f`.
  have hg_bound := hg.bound_forall_range (n + 1)
  have hf_bound := hf.bound_forall_range (n + 1)
  simp [Nat.lt_succ] at hg_bound
  simp [Nat.lt_succ] at hf_bound
  rcases hg_bound with ‚ü®k_g, C_g, ‚ü®hC_g_nonneg, hC_g‚ü©‚ü©
  rcases hf_bound with ‚ü®k_f, C_f, ‚ü®_, hC_f‚ü©‚ü©
  -- Also obtain `k, C` for f itself to bound `(1 + ‚Äñf x‚Äñ) ^ k_g` by a power of `1 + ‚Äñx‚Äñ`.
  have hf0 := hf.2 0
  simp at hf0
  rcases hf0 with ‚ü®k_f0, C_f0, hC_f0‚ü©

  -- Eventually need to show:
  -- `n.factorial * (C_g * (2 * max 1 C_f0 * (1 + ‚Äñx‚Äñ) ^ k_f0) ^ k_g) * (max 1 C_f * (1 + ‚Äñx‚Äñ) ^ k_f) ^ n ‚â§ C * (1 + ‚Äñx‚Äñ) ^ k`
  -- Choose `k, C` accordingly.
  use k_f0 * k_g + k_f * n
  use n.factorial * C_g * (2 * max 1 C_f0) ^ k_g * (max 1 C_f) ^ n
  intro x

  -- Establish bounds required for `norm_iteratedFDeriv_comp_le`.
  -- First obtain a bound for `1 + ‚Äñf x‚Äñ` to avoid a `(1 + ‚Äñf x‚Äñ) ^ k_g` term on the left.
  have hf0 : (1 + ‚Äñf x‚Äñ) ‚â§ 2 * max 1 C_f0 * (1 + ‚Äñx‚Äñ) ^ k_f0
  . rw [mul_assoc, two_mul]
    refine add_le_add ?_ ?_
    . simp [one_le_mul_of_one_le_of_one_le]
    . exact le_trans (hC_f0 x) (by simp)
  -- Bound derivatives of `g` at `f x` by a constant `C`.
  have hC : ‚àÄ (i : ‚Ñï), i ‚â§ n ‚Üí ‚ÄñiteratedFDeriv ‚Ñù i g (f x)‚Äñ ‚â§ C_g * (2 * max 1 C_f0 * (1 + ‚Äñx‚Äñ) ^ k_f0) ^ k_g
  . intro i hi
    refine le_trans (hC_g i hi (f x)) ?_
    refine mul_le_mul_of_nonneg_left ?_ hC_g_nonneg
    exact pow_le_pow_of_le_left (by simp) hf0 k_g
  -- Bound derivatives of `f` at `x` by non-zero powers of `D`.
  have hD : ‚àÄ i, 1 ‚â§ i ‚Üí i ‚â§ n ‚Üí ‚ÄñiteratedFDeriv ‚Ñù i f x‚Äñ ‚â§ (max 1 C_f * (1 + ‚Äñx‚Äñ) ^ k_f) ^ i
  . intro i _ hi
    refine le_trans (hC_f i hi x) ?_
    refine le_trans (mul_le_mul_of_nonneg_right (le_max_right 1 C_f) (by simp)) ?_
    refine le_self_pow ?_ (by linarith)
    exact one_le_mul_of_one_le_of_one_le (le_max_left 1 C_f) (by simp)
  refine le_trans (norm_iteratedFDeriv_comp_le hg.1 hf.1 le_top x hC hD) ?_
  refine le_of_eq ?_
  ring_nf


lemma Function.HasTemperateGrowth.comp_clm [Nontrivial E]
    {g : F ‚Üí G} (hg : HasTemperateGrowth g) (f : E ‚ÜíL[‚Ñù] F) :
    Function.HasTemperateGrowth fun x => g (f x) :=
  comp hg clm

lemma Function.HasTemperateGrowth.clm_comp [Nontrivial F]
    (g : F ‚ÜíL[‚Ñù] G) {f : E ‚Üí F} (hf : HasTemperateGrowth f) :
    Function.HasTemperateGrowth fun x => g (f x) :=
  comp clm hf

end Compose


namespace Complex

variable {ùïú E : Type*}
variable [NontriviallyNormedField ùïú] [NormedAlgebra ùïú ‚Ñù]
variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]

lemma contDiff_exp_real_smul_I {n : ‚Ñï‚àû} : ContDiff ‚Ñù n fun x : ‚Ñù => exp (x ‚Ä¢ I) :=
  ContDiff.cexp (ContDiff.smul contDiff_id contDiff_const)

lemma contDiff_exp_real_neg_smul_I {n : ‚Ñï‚àû} : ContDiff ‚Ñù n fun x : ‚Ñù => exp (-x ‚Ä¢ I) :=
  ContDiff.cexp (ContDiff.smul contDiff_neg contDiff_const)

lemma _root_.ContDiff.cexp_real_smul_I {n : ‚Ñï‚àû} {f : E ‚Üí ‚Ñù} (hf : ContDiff ‚Ñù n f) :
    ContDiff ‚Ñù n fun x => Complex.exp (f x ‚Ä¢ I) :=
  contDiff_exp_real_smul_I.comp hf

lemma deriv_exp_real_smul_I_apply {x : ‚Ñù} :
    deriv (fun x : ‚Ñù => exp (x ‚Ä¢ I)) x = I * exp (x ‚Ä¢ I) := by
  change deriv (exp ‚àò fun x => (x ‚Ä¢ I)) x = I * cexp (x ‚Ä¢ I)
  rw [deriv.comp _ differentiableAt_exp (differentiableAt_id.smul_const I)]
  rw [Complex.deriv_exp]
  rw [mul_comm]
  congr
  rw [deriv_smul_const differentiableAt_id]
  simp

lemma iteratedDeriv_exp_real_smul_I_apply {n : ‚Ñï} {x : ‚Ñù} :
    iteratedDeriv n (fun x : ‚Ñù => exp (x ‚Ä¢ I)) x = HPow.hPow I n * exp (x ‚Ä¢ I) := by
  induction n with
  | zero => simp
  | succ n hi =>
    rw [iteratedDeriv_succ', pow_succ]
    conv => lhs; arg 2; intro x
    simp only [deriv_exp_real_smul_I_apply]
    rw [iteratedDeriv_const_mul_apply I contDiff_exp_real_smul_I]
    rw [hi, mul_assoc]

lemma deriv_comp_exp_real_smul_I_apply {f : ùïú ‚Üí ‚Ñù} (hf : Differentiable ùïú f) {x : ùïú} :
    deriv (fun x => exp (f x ‚Ä¢ I)) x = cexp (f x ‚Ä¢ I) * (deriv f x ‚Ä¢ I) := by
  change deriv (exp ‚àò (fun x => f x ‚Ä¢ I)) x = _
  rw [deriv.comp _ differentiableAt_exp (hf.smul_const I).differentiableAt]
  rw [deriv_smul_const hf.differentiableAt]
  simp

-- Prove some convenience lemmata for `fun x : ‚Ñù => exp ((a * x) ‚Ä¢ I)`.

lemma contDiff_exp_const_mul_real_smul_I {n : ‚Ñï‚àû} {a : ‚Ñù} :
    ContDiff ‚Ñù n fun x : ‚Ñù => exp ((a * x) ‚Ä¢ I) :=
  ContDiff.cexp_real_smul_I (contDiff_const.mul contDiff_id)

-- TODO: Use comp with CLM?
lemma deriv_exp_const_mul_real_smul_I_apply {a : ‚Ñù} {x : ‚Ñù} :
    deriv (fun x : ‚Ñù => exp ((a * x) ‚Ä¢ I)) x = (a ‚Ä¢ I) * exp ((a * x) ‚Ä¢ I) := by
  rw [deriv_comp_exp_real_smul_I_apply]
  swap
  . exact differentiable_id.const_mul a
  rw [mul_comm]
  congr
  rw [deriv_const_mul _ differentiableAt_id]
  simp

-- TODO: Use comp with CLM?
lemma iteratedDeriv_exp_const_mul_real_smul_I_apply {n : ‚Ñï} {a : ‚Ñù} {x : ‚Ñù} :
    iteratedDeriv n (fun x : ‚Ñù => exp ((a * x) ‚Ä¢ I)) x = HPow.hPow (a ‚Ä¢ I) n * exp ((a * x) ‚Ä¢ I) := by
  induction n with
  | zero => simp
  | succ n hi =>
    rw [iteratedDeriv_succ', pow_succ]
    conv => lhs; arg 2; intro x
    simp only [deriv_exp_const_mul_real_smul_I_apply]
    rw [iteratedDeriv_const_mul_apply _ contDiff_exp_const_mul_real_smul_I]
    rw [hi, mul_assoc]

-- TODO: Would it make sense to provide this for `ùïú`-linearity?
/-- Analogy of `fderiv_exp` for complex exponential. -/
lemma _root_.fderiv_cexp_real {f : E ‚Üí ‚ÑÇ} {x : E} (hf : DifferentiableAt ‚Ñù f x) :
    fderiv ‚Ñù (fun x => exp (f x)) x = cexp (f x) ‚Ä¢ fderiv ‚Ñù f x := by
  change fderiv ‚Ñù (exp ‚àò f) x = _
  rw [fderiv.comp x differentiable_exp.differentiableAt hf]
  rw [(hasStrictFDerivAt_exp_real (f x)).hasFDerivAt.fderiv]
  simp [ContinuousLinearMap.one_def]


-- How to write smul as application of a CLM.
example {a : ‚Ñù} : a ‚Ä¢ I = a ‚Ä¢ (ContinuousLinearMap.id ‚Ñù ‚ÑÇ) I := rfl

-- TODO: Proof is long but should be trivial?
-- TODO: Should this hold with equality?
lemma _root_.norm_iteratedFDeriv_smul_I_le {n : ‚Ñï} {f : E ‚Üí ‚Ñù} (hf : ContDiff ‚Ñù ‚ä§ f) {x : E} :
    ‚ÄñiteratedFDeriv ‚Ñù n (fun x => f x ‚Ä¢ I) x‚Äñ ‚â§ ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ := by
  -- Tried using `norm_iteratedFDeriv_clm_apply_const` with `norm_iteratedFDeriv_smul_le`.
  -- However, it was no easier than before; just replaced `I` with `ContinuousLinearMap.id`
  -- change ‚ÄñiteratedFDeriv ‚Ñù n (fun x => (f x ‚Ä¢ ContinuousLinearMap.id ‚Ñù ‚ÑÇ) I) x‚Äñ ‚â§ ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ
  -- refine le_trans (norm_iteratedFDeriv_clm_apply_const ?_ le_top) ?_
  -- . exact ContDiff.smul hf contDiff_const
  -- simp

  refine le_trans (norm_iteratedFDeriv_smul_le hf contDiff_const _ le_top) ?_
  -- All terms are zero except `i = 0`.
  -- Non-trivial due to `Fin (n - n) ‚â† Fin 0`.
  -- Rewrite and flip the order of the sum to eliminate.
  rw [Finset.sum_congr rfl (g := fun i =>
      n.choose (n - i) * ‚ÄñiteratedFDeriv ‚Ñù (n - (n - i)) f x‚Äñ * ‚ÄñiteratedFDeriv ‚Ñù (n - i) (fun _ => I) x‚Äñ)]
  swap
  . intro i hi
    simp at hi
    rw [Nat.choose_symm (Nat.le_of_lt_succ hi)]
    rw [Nat.sub_sub_self (Nat.le_of_lt_succ hi)]
  rw [Finset.sum_flip (fun u =>
      n.choose u * ‚ÄñiteratedFDeriv ‚Ñù (n - u) f x‚Äñ * ‚ÄñiteratedFDeriv ‚Ñù u (fun _ => I) x‚Äñ)]
  rw [add_comm n 1]
  rw [Finset.sum_range_add]
  simp  -- Yay!
  refine le_of_eq ?_
  refine Finset.sum_eq_zero ?_
  intro i _
  simp
  right
  rw [iteratedFDeriv_const_of_ne] <;> simp

/--
The imaginary exponential of a real-valued `HasTemperateGrowth` function is a `HasTemperateGrowth` function.

TODO: Prove for more general `g : E ‚Üí ‚ÑÇ` with `|(g x).re| ‚â§ 1`?
-/
theorem _root_.Function.HasTemperateGrowth.exp_real_smul_I {f : E ‚Üí ‚Ñù} (hf : Function.HasTemperateGrowth f) :
    Function.HasTemperateGrowth fun x => exp (f x ‚Ä¢ I) := by
  refine ‚ü®?_, ?_‚ü©
  . exact ContDiff.cexp_real_smul_I hf.1
  . intro n
    induction n using Nat.caseStrongInductionOn with
    | zero =>
      refine ‚ü®0, 1, ?_‚ü©
      simp
    | ind n h_ind =>
      simp [iteratedFDeriv_succ_eq_comp_right, -real_smul]
      have hf_diff := hf.1.differentiable le_top
      simp_rw [fderiv_cexp_real (hf_diff.smul_const I).differentiableAt]
      clear hf_diff

      -- Find bounding monomials for both terms for all `i`.
      have h‚ÇÅ : ‚àÉ k‚ÇÅ C‚ÇÅ, 0 ‚â§ C‚ÇÅ ‚àß ‚àÄ i, i < n + 1 ‚Üí ‚àÄ x, ‚ÄñiteratedFDeriv ‚Ñù i (fun y => cexp (f y ‚Ä¢ I)) x‚Äñ ‚â§ C‚ÇÅ * (1 + ‚Äñx‚Äñ) ^ k‚ÇÅ
      . refine _root_.bound_forall_range (n + 1) ?_
        intro i hi
        exact h_ind i (Nat.le_of_lt_succ hi)

      -- Note: Technically don't need to include case `i = 0` here.
      have h‚ÇÇ : ‚àÉ k‚ÇÇ C‚ÇÇ, 0 ‚â§ C‚ÇÇ ‚àß ‚àÄ i, i < n + 2 ‚Üí ‚àÄ x, ‚ÄñiteratedFDeriv ‚Ñù i (fun y => f y ‚Ä¢ I) x‚Äñ ‚â§ C‚ÇÇ * (1 + ‚Äñx‚Äñ) ^ k‚ÇÇ
      . refine _root_.bound_forall_range (n + 2) ?_
        intro i _
        rcases hf.2 i with ‚ü®k, C, hC‚ü©
        refine ‚ü®k, C, ?_‚ü©
        intro x
        specialize hC x
        refine le_trans ?_ hC
        exact norm_iteratedFDeriv_smul_I_le hf.1

      rcases h‚ÇÅ with ‚ü®k‚ÇÅ, C‚ÇÅ, ‚ü®hC‚ÇÅ_nonneg, hC‚ÇÅ‚ü©‚ü©
      rcases h‚ÇÇ with ‚ü®k‚ÇÇ, C‚ÇÇ, ‚ü®_, hC‚ÇÇ‚ü©‚ü©
      refine ‚ü®k‚ÇÅ + k‚ÇÇ, 2 ^ n * C‚ÇÅ * C‚ÇÇ, ?_‚ü©
      intro x
      refine le_trans (norm_iteratedFDeriv_smul_le ?_ ?_ _ le_top) ?_
      . exact ContDiff.cexp_real_smul_I hf.1
      . refine ContDiff.fderiv_right ?_ le_top
        exact ContDiff.smul hf.1 contDiff_const
      simp_rw [norm_iteratedFDeriv_fderiv]

      -- Now use the two bounds above.
      simp only [mul_assoc]
      simp only [‚Üê nsmul_eq_mul]
      refine Finset.sum_range_choose_smul_le_pow_two_smul ?_
      intro i hi
      simp at hi
      specialize hC‚ÇÅ i hi x
      specialize hC‚ÇÇ (n - i + 1) ?_ x
      . refine Nat.succ_le_succ ?_
        refine Nat.succ_le_succ ?_
        exact Nat.sub_le n i
      refine le_of_le_of_eq (mul_le_mul hC‚ÇÅ hC‚ÇÇ ?_ ?_) ?_
      . exact norm_nonneg _
      . exact mul_nonneg hC‚ÇÅ_nonneg (by simp)
      ring_nf

-- TODO: Implement in terms of more general method applied to `id`.
lemma hasTemperateGrowth_exp_real_smul_I :
    Function.HasTemperateGrowth fun x : ‚Ñù => exp (x ‚Ä¢ I) :=
  Function.HasTemperateGrowth.exp_real_smul_I (Function.hasTemperateGrowth_id ‚Ñù)

-- TODO: Generalize to `f x` with bound on growth?
-- Could there be a `HasTemperateGrowth.comp`? At least with a `ContinuousLinearMap`?
lemma hasTemperateGrowth_exp_const_mul_real_smul_I {a : ‚Ñù} :
    Function.HasTemperateGrowth fun x : ‚Ñù => exp ((a * x) ‚Ä¢ I) :=
  Function.HasTemperateGrowth.exp_real_smul_I Real.hasTemperateGrowth_mul_left

-- /-- More general than `contDiff_sin`; matches `contDiff_exp`. -/
-- lemma contDiff_sin' {ùïú : Type*} [NontriviallyNormedField ùïú] [NormedAlgebra ùïú ‚ÑÇ] :
--     ContDiff ùïú ‚ä§ sin := by
--   simp [sin]
--   refine ContDiff.div_const (ContDiff.mul ?_ contDiff_const) 2
--   refine ContDiff.sub ?_ ?_
--   . exact ContDiff.cexp (ContDiff.neg (ContDiff.mul contDiff_id contDiff_const))
--   . exact ContDiff.cexp (ContDiff.mul contDiff_id contDiff_const)

-- /-- More general than `contDiff_cos`; matches `contDiff_exp`. -/
-- lemma contDiff_cos' {ùïú : Type*} [NontriviallyNormedField ùïú] [NormedAlgebra ùïú ‚ÑÇ] :
--     ContDiff ùïú ‚ä§ cos := by
--   simp [cos]
--   refine ContDiff.div_const ?_ 2
--   refine ContDiff.add ?_ ?_
--   . exact ContDiff.cexp (ContDiff.mul contDiff_id contDiff_const)
--   . exact ContDiff.cexp (ContDiff.neg (ContDiff.mul contDiff_id contDiff_const))

end Complex


namespace Real

-- Tried using `ContinuousLinearMap.norm_compContinuousMultilinearMap_le` with
-- `‚ÄñiteratedFDeriv ‚Ñù n (Complex.reClm ‚àò Complex.sin ‚àò Complex.ofRealClm) x‚Äñ ‚â§ 1`
-- and then using `LinearIsometryEquiv.norm_iteratedFDeriv_comp_right` with
-- `‚ÄñiteratedFDeriv ‚Ñù n ((Complex.sin ‚àò Subtype.val) ‚àò Complex.ofRealLi.equivRange) x‚Äñ ‚â§ 1`
-- but it was difficult to use the last `Subtype.val`.
-- Easier to just prove `sin` and `cos` together by induction.
-- Could revisit and refer to `ContDiffAt.real_of_complex` as a guide.

/-- Auxiliary function for `abs_iteratedDeriv_{sin,cos}_le`. -/
lemma abs_iteratedDeriv_sin_cos_le {n : ‚Ñï} {x : ‚Ñù} :
    |iteratedDeriv n sin x| ‚â§ 1 ‚àß |iteratedDeriv n cos x| ‚â§ 1 := by
  induction n with
  | zero => simp; exact ‚ü®abs_sin_le_one x, abs_cos_le_one x‚ü©
  | succ n hi =>
    simp [iteratedDeriv_succ']
    refine ‚ü®hi.right, ?_‚ü©
    simp [iteratedDeriv_neg_apply]
    exact hi.left

lemma abs_iteratedDeriv_sin_le {n : ‚Ñï} {x : ‚Ñù} : |iteratedDeriv n sin x| ‚â§ 1 :=
  abs_iteratedDeriv_sin_cos_le.left

lemma abs_iteratedDeriv_cos_le {n : ‚Ñï} {x : ‚Ñù} : |iteratedDeriv n cos x| ‚â§ 1 :=
  abs_iteratedDeriv_sin_cos_le.right

lemma hasTemperateGrowth_sin : Function.HasTemperateGrowth sin := by
  refine ‚ü®contDiff_sin, ?_‚ü©
  intro n
  refine ‚ü®1, 1, ?_‚ü©
  intro x
  simp
  rw [norm_iteratedFDeriv_eq_norm_iteratedDeriv]
  exact le_trans abs_iteratedDeriv_sin_le (le_add_of_nonneg_right (abs_nonneg x))

lemma hasTemperateGrowth_cos : Function.HasTemperateGrowth cos := by
  refine ‚ü®contDiff_cos, ?_‚ü©
  intro n
  refine ‚ü®1, 1, ?_‚ü©
  intro x
  simp
  rw [norm_iteratedFDeriv_eq_norm_iteratedDeriv]
  exact le_trans abs_iteratedDeriv_cos_le (le_add_of_nonneg_right (abs_nonneg x))

lemma hasTemperateGrowth_fourierChar_mul' (w : ‚Ñù) :
    Function.HasTemperateGrowth fun v : ‚Ñù => Complex.exp (‚Üë(-(2 * œÄ * v * w)) * Complex.I) := by
  simp_rw [‚Üê Complex.real_smul]
  simp_rw [mul_assoc _ _ w, mul_comm _ w, ‚Üê mul_assoc _ w]
  simp_rw [‚Üê neg_mul]
  exact Complex.hasTemperateGrowth_exp_const_mul_real_smul_I

lemma hasTemperateGrowth_fourierChar_mul (w : ‚Ñù) :
    Function.HasTemperateGrowth fun v : ‚Ñù => (fourierChar (Multiplicative.ofAdd (-(v * w))) : ‚ÑÇ) := by
  simp_rw [fourierChar_apply]
  simp_rw [mul_neg]
  simp_rw [‚Üê mul_assoc]
  exact hasTemperateGrowth_fourierChar_mul' w

end Real


-- section Vector

-- variable {E : Type*}
-- variable [NormedAddCommGroup E] [InnerProductSpace ‚Ñù E]

-- lemma hasTemperateGrowth_fourierChar_mul (w : E) :
--     Function.HasTemperateGrowth fun v : E => Complex.exp (‚Üë(-(2 * œÄ * inner v w)) * Complex.I) := by
--   simp
--   sorry
--   -- simp_rw [‚Üê Complex.real_smul]
--   -- simp_rw [mul_assoc _ _ w, mul_comm _ w, ‚Üê mul_assoc _ w]
--   -- simp_rw [‚Üê neg_mul]
--   -- exact Complex.hasTemperateGrowth_exp_const_mul_real_smul_I

-- end Vector
