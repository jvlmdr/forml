import Mathlib.Analysis.Distribution.SchwartzSpace
import Mathlib.Analysis.SpecialFunctions.JapaneseBracket
import Mathlib.MeasureTheory.Function.L1Space
import Mathlib.MeasureTheory.Integral.Bochner
import Mathlib.MeasureTheory.Measure.VectorMeasure

import ForML.LpHoelder
import ForML.SchwartzLp

-- https://github.com/leanprover/lean4/issues/2220
local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y)

open MeasureTheory SchwartzSpace
open scoped BigOperators Real NNReal ENNReal

-- Plan is to define mapping from `L1` to `L1`,
-- then show continuous,
-- then transfer to `ùì¢(E, F)` using `ContinuousLinearMap.comp`.

namespace SchwartzMap

variable {ùïú : Type*} [NontriviallyNormedField ùïú]
variable {E F : Type*}
variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
variable [mE : MeasureSpace E] [FiniteDimensional ‚Ñù E] [BorelSpace E] [mE.volume.IsAddHaarMeasure]
variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
variable [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]


-- TODO: Define using `g : Lp (Œ± := E) ùïú p` or just `g : E ‚Üí ùïú`?
noncomputable def integral_Lp_smul {p : ENNReal}
    (g : Lp (Œ± := E) ùïú p) (œÜ : ùì¢(E, F)) : F :=
  ‚à´ (x : E), g x ‚Ä¢ œÜ x

lemma integral_Lp_smul_def {p : ENNReal} {g : Lp (Œ± := E) ùïú p} {œÜ : ùì¢(E, F)} :
    integral_Lp_smul g œÜ = ‚à´ (x : E), g x ‚Ä¢ œÜ x := by rfl

-- TODO: Define these as bilinear CLM? Although depends on topology of `g`?
lemma integral_Lp_smul_add {p : ENNReal} (hp : 1 ‚â§ p)
    (g : Lp (Œ± := E) ùïú p) (œÜ Œ∏ : ùì¢(E, F)) :
    integral_Lp_smul g (œÜ + Œ∏) = integral_Lp_smul g œÜ + integral_Lp_smul g Œ∏ := by
  simp [integral_Lp_smul]
  have hpq := ENNReal.conjugate_conjugateExponent hp
  generalize p.conjugateExponent = q at hpq
  rw [integral_add]
  . exact integrable_Lp_smul_Lq hpq (Lp.mem‚Ñíp g) (œÜ.mem‚Ñíp q)
  . exact integrable_Lp_smul_Lq hpq (Lp.mem‚Ñíp g) (Œ∏.mem‚Ñíp q)

-- Note: Doesn't require `1 ‚â§ p`?
lemma integral_Lp_smul_smul {p : ENNReal}
    (g : Lp (Œ± := E) ùïú p) (c : ùïú) (œÜ : ùì¢(E, F)) :
    integral_Lp_smul g (c ‚Ä¢ œÜ) = c ‚Ä¢ integral_Lp_smul g œÜ := by
  simp [integral_Lp_smul]
  simp_rw [smul_comm _ c]
  rw [integral_smul]

/-- `L1.integral` of `L1_of_Lp_smul_Lq _ _ (SchwartzMap.toLp œÜ _)` as an integral. -/
lemma L1_integral_Lp_smul_Lq_eq_integral {p q : ENNReal} (hpq : p‚Åª¬π + q‚Åª¬π = 1) {g : Lp (Œ± := E) ùïú p} {œÜ : ùì¢(E, F)} :
    L1.integral (L1_of_Lp_smul_Lq hpq g (œÜ.toLp q)) = ‚à´ (x : E), g x ‚Ä¢ œÜ x := by
  rw [L1.integral_eq_integral]
  rw [integral_congr_ae (coeFn_L1_of_Lp_smul_Lq hpq)]
  refine integral_congr_ae ?_
  simp
  refine Filter.EventuallyEq.smul (by rfl) ?_
  exact SchwartzMap.coeFn_toLp _


-- Want to define `œÜ ‚Ü¶ ‚à´ x, f x ‚Ä¢ œÜ x` as a CLM `ùì¢(E, F) ‚ÜíL[ùïú] F` where `f : Lp ùïú p`.
-- Two options for how to do this...
--
-- 1. Define `g ‚Ü¶ f ‚Ä¢ g` as a CLM `Lp_smul_CLM g : Lp F q ‚ÜíL[ùïú] Lp F 1`,
-- then use `integralCLM ‚àò Lp_smul_CLM g ‚àò SchwartzMap.toLp_CLM`.
-- TODO: Implement `SchwartzMap.toLp_CLM` rather than `SchwartzMap.toL1_CLM`.
--
-- 2. Define `œÜ ‚Ü¶ f ‚àò œÜ` as a CLM `SchwartzMap.Lp_smul_CLM g : ùì¢(E, F) ‚ÜíL[ùïú] ùì¢(E, F)`,
-- then use `integralCLM ‚àò SchwartzMap.toL1_CLM ‚àò SchwartzMap.Lp_smul_CLM g`.
-- This requires that `g ‚Ä¢ œÜ` is a Schwartz map...
-- Which kind of functions
--
-- Option 1 is more broadly useful (for `Lp` rather than just `SchwartzMap`).
-- Option 2 is specific to `SchwartzMap`, but this may be advantageous.
-- For example, we can easily go from `SchwartzMap` to `Lp` but not vice versa.
-- Perhaps this could be remedied showing that `SchwartzMap` is dense in `Lp`?

-- Actually, multiplication by Lp is not general enough!
-- For example, polynomials are tempered distributions, but they are not in Lp for any p.
-- Instead consider multiplication by a function that `HasTemperateGrowth`.
-- Note that this is not general enough to capture all tempered distributions.
-- For example, `x ‚Ü¶ sign x` or `x ‚Ü¶ max 0 x`.

-- TODO: Eventually define as bilinear CLM `Lp ùïú p ‚ÜíL[ùïú] ùì¢(E, F) ‚ÜíL[ùïú] F`?
-- Check type classes.
#check fun (p : ‚Ñù‚â•0‚àû) [Fact (1 ‚â§ p)] => Lp (Œ± := E) ùïú p ‚ÜíL[ùïú] ùì¢(E, F) ‚ÜíL[ùïú] F

-- Can we follow `SchwartzMap.evalCLM` and use `SchwartzMap E (E ‚ÜíL[‚Ñù] F)`?
-- Maybe it's better to propose notation `E ‚Üíùì¢ F` and `E ‚Üí‚Ñí[p] ùïú`?
-- We have a function `smul g œÜ x : F`. Rewrite as `smul x g œÜ`?
-- This might have type... `SchwartzMap E (Lp {E} ùïú p ‚ÜíL[ùïú] F)`?
-- Check type classes.
-- #check fun (p : ‚Ñù‚â•0‚àû) [Fact (1 ‚â§ p)] => SchwartzMap E (Lp (Œ± := E) ùïú p ‚ÜíL[ùïú] F)
-- This would require `NormedSpace ‚Ñù (Lp {E} ùïú p ‚ÜíL[ùïú] F)`.
-- That is, linear functionals on `Lp` as a `NormedSpace`? What's missing? `SMul ‚Ñù` etc.
-- Although, if we *can* this, can we still obtain the *integral* of `f ‚Ä¢ œÜ` as a CLM?

lemma coeFn_apply {f : ùì¢(E, F)} {x : E} : f x = f.toFun x := rfl

lemma coeFn {f : ùì¢(E, F)} : f = f.toFun := rfl


/-- The product of a Schwartz function and a function with polynomial-bounded derivatives as a Schwartz function.

Requires `g : E ‚Üí ‚Ñù` rather than `g : E ‚Üí ùïú` in order to use `ContDiff.smul`.
TODO: May be possible to generalize to `g : E ‚Üí ùïú'`?
-/
def hasTemperateGrowth_smul {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g)
    (f : ùì¢(E, F)) : ùì¢(E, F) where
  toFun := g ‚Ä¢ (f : E ‚Üí F)
  smooth' := ContDiff.smul hg.1 (f.smooth ‚ä§)
  decay' := by
    refine decay_of_decay‚ÇÅ ?_
    intro k n
    -- Change goal using bound on norm_iteratedFDeriv_smul.
    have h_deriv (x : E) (n : ‚Ñï) := norm_iteratedFDeriv_smul_le hg.1 (f.smooth ‚ä§) x (le_top : (n : ENat) ‚â§ ‚ä§)
    -- TODO: Should be possible to avoid writing out long proposition?
    -- refine Exists.imp (fun C h x => le_trans (mul_le_mul_of_nonneg_left (h_deriv x n) (by simp)) (h x)) ?_
    have (C) :
        (‚àÄ (x : E), (1 + ‚Äñx‚Äñ) ^ k * (‚àë i in Finset.range (n + 1),
          n.choose i * ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ * ‚ÄñiteratedFDeriv ‚Ñù (n - i) f x‚Äñ) ‚â§ C) ‚Üí
        (‚àÄ (x : E), (1 + ‚Äñx‚Äñ) ^ k * ‚ÄñiteratedFDeriv ‚Ñù n (g ‚Ä¢ (f : E ‚Üí F)) x‚Äñ ‚â§ C)
    . intro h x
      refine le_trans ?_ (h x)
      exact mul_le_mul_of_nonneg_left (h_deriv x n) (by simp)
    refine Exists.imp this ?_
    clear this h_deriv
    -- If we have an upper bound for each summand, then we have an upper bound for the sum.
    -- Easier to define in abstract terms. Could extract as a lemma?
    have (q : ‚Ñï ‚Üí E ‚Üí ‚Ñù) (m : ‚Ñï) :
        (‚àÄ i ‚àà Finset.range m, ‚àÉ C, ‚àÄ x, q i x ‚â§ C) ‚Üí (‚àÉ C, ‚àÄ x, ‚àë i in Finset.range m, q i x ‚â§ C)
    . intro h
      have := Finset.sum_induction q (fun (qi : E ‚Üí ‚Ñù) => ‚àÉ C, ‚àÄ x, qi x ‚â§ C) ?_ ?_ h
      rotate_left
      . simp
        intro qi qi' C hi C' hi'
        use C + C'
        intro x
        exact add_le_add (hi x) (hi' x)
      . simp
        use 0
      simp at this
      exact this
    -- Move the multiplier inside the summation and then apply.
    simp [Finset.mul_sum]
    refine this _ _ ?_
    clear this
    intro i _
    have hg_temp := hg.2
    have hf_decay‚ÇÅ := f.decay‚ÇÅ
    specialize hg_temp i
    rcases hg_temp with ‚ü®k_g, ‚ü®C_g, hC_g‚ü©‚ü©
    -- Want to choose `k_f` such that we can use
    -- `(1 + ‚Äñx‚Äñ) ^ k_f * ‚ÄñiteratedFDeriv ‚Ñù (n - i) f x‚Äñ ‚â§ C_f`
    -- with the existing condition
    -- `‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ ‚â§ C_g * (1 + ‚Äñx‚Äñ) ^ k_g`
    -- to obtain
    -- `(1 + ‚Äñx‚Äñ) ^ k * ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ * ‚ÄñiteratedFDeriv ‚Ñù (n - i) f x‚Äñ ‚â§ C_g * C_f`.
    -- The two conditions together give us
    -- `(1 + ‚Äñx‚Äñ) ^ k_f * ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ * ‚ÄñiteratedFDeriv ‚Ñù (n - i) f x‚Äñ ‚â§ C_g * C_f * (1 + ‚Äñx‚Äñ) ^ k_g`
    -- `(1 + ‚Äñx‚Äñ) ^ k_f * (1 + ‚Äñx‚Äñ)‚Åª¬π ^ k_g * ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ * ‚ÄñiteratedFDeriv ‚Ñù (n - i) f x‚Äñ ‚â§ C_g * C_f`
    -- Therefore, use `k_f = k + k_g`.
    specialize hf_decay‚ÇÅ (k + k_g) (n - i)
    rcases hf_decay‚ÇÅ with ‚ü®C_f, hC_f‚ü©
    use n.choose i * C_g * C_f
    intro x
    specialize hC_g x
    specialize hC_f x
    simp [pow_add] at hC_f
    -- Eliminate the `choose` term.
    simp [‚Üê mul_assoc]
    rw [mul_comm _ (Nat.choose _ _ : ‚Ñù)]
    simp [mul_assoc]
    refine mul_le_mul_of_nonneg_left ?_ (Nat.cast_nonneg _)
    simp [‚Üê mul_assoc]
    -- Take product of two conditions, then just re-arrange.
    -- Eliminate the `(1 + ‚Äñx‚Äñ) ^ k_g` term.
    rw [mul_comm] at hC_g
    rw [mul_comm (_ ^ _) (_ ^ _)] at hC_f
    have := mul_le_mul hC_g hC_f ?_ ?_
    rotate_left
    . refine mul_nonneg (mul_nonneg ?_ ?_) ?_ <;> simp
    . exact le_trans (by simp) hC_g
    rw [mul_comm] at this
    simp [mul_assoc] at this
    rw [mul_comm ‚Äñ_‚Äñ ‚Äñ_‚Äñ] at this
    simp [‚Üê mul_assoc] at this
    exact this


lemma hasTemperateGrowth_smul_apply {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g) (f : ùì¢(E, F)) :
    hasTemperateGrowth_smul hg f x = g x ‚Ä¢ f x := rfl

lemma coeFn_hasTemperateGrowth_smul {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g) (f : ùì¢(E, F)) :
    hasTemperateGrowth_smul hg f = fun x => g x ‚Ä¢ f x := rfl

lemma hasTemperateGrowth_smul_add {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g) (œÜ Œ∏ : ùì¢(E, F)) :
    hasTemperateGrowth_smul hg (œÜ + Œ∏) = hasTemperateGrowth_smul hg œÜ + hasTemperateGrowth_smul hg Œ∏ := by
  ext x
  simp [hasTemperateGrowth_smul_apply]

lemma hasTemperateGrowth_smul_smul {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g) (c : ùïú) (œÜ : ùì¢(E, F)) :
    hasTemperateGrowth_smul hg (c ‚Ä¢ œÜ) = c ‚Ä¢ hasTemperateGrowth_smul hg œÜ := by
  ext x
  simp [hasTemperateGrowth_smul_apply]
  rw [smul_comm]


-- TODO: Could it be easier to prove `cont` directly, rather than use `mkCLM`?

-- /-- Bound the seminorm of `g ‚Ä¢ f` by the seminorm of `f` for `mkCLM`. -/
-- lemma hasTemperateGrowth_smul_bound_le {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g)
--     (k n : ‚Ñï) (f : ùì¢(E, F)) (x : E) (C' : ‚Ñù) :
--     ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n (fun x => g x ‚Ä¢ f x) x‚Äñ ‚â§
--       C' * (Finset.Iic (k, n)).sup (schwartzSeminormFamily ùïú E F) f := by
--   -- Already showed that `g ‚Ä¢ f` is a Schwartz function.
--   -- Do we have the required bound from that?
--   simp_rw [‚Üê coeFn_hasTemperateGrowth_smul hg]
--   have hgf := (hasTemperateGrowth_smul hg f).decay k n
--   rcases hgf with ‚ü®C_gf, hC_gf, hgf‚ü©
--   specialize hgf x
--   refine le_trans hgf ?_
--   have hf := f.decay k n
--   simp [schwartzSeminormFamily]
--   sorry


-- Not good enough for `mkCLM`; upper bound depends on `x`!
lemma hasTemperateGrowth_smul_bound' {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g) (k n : ‚Ñï) :
    ‚àÄ (f : ùì¢(E, F)) (x : E),
      ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n (fun x => g x ‚Ä¢ f x) x‚Äñ ‚â§
        (‚Üë(2 ^ k : ‚Ñï) * (‚àë i in Finset.range (n + 1), (n.choose i) * ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ)) *
          (Finset.Iic (k, n)).sup (schwartzSeminormFamily ùïú E F) f := by
  intro f x
  -- Apply `norm_iteratedFDeriv_smul_le` to obtain sum.
  refine le_trans (mul_le_mul_of_nonneg_left
    (norm_iteratedFDeriv_smul_le hg.1 (f.smooth ‚ä§) x le_top)
    (pow_nonneg (norm_nonneg x) _)) ?_

  -- Move `‚Äñx‚Äñ ^ k` inside sum and bound each summand.
  rw [Finset.mul_sum]
  suffices : ‚àÄ i ‚àà Finset.range (n + 1),
      ‚Äñx‚Äñ ^ k * ((n.choose i) * ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ * ‚ÄñiteratedFDeriv ‚Ñù (n - i) f x‚Äñ) ‚â§
      ‚Üë(2 ^ k : ‚Ñï) * ((n.choose i) * ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ) * ((Finset.Iic (k, n)).sup (schwartzSeminormFamily ùïú E F) f)
  . refine le_trans (Finset.sum_le_sum this) ?_
    rw [‚Üê Finset.sum_mul, ‚Üê Finset.mul_sum]

  intro i hi
  -- Move common terms to the left.
  rw [mul_comm (‚Äñx‚Äñ ^ k)]
  rw [mul_assoc (‚Üë(2 ^ k) : ‚Ñù)]
  rw [mul_comm (‚Üë(2 ^ k) : ‚Ñù)]
  simp only [mul_assoc]
  refine mul_le_mul_of_nonneg_left ?_ (Nat.cast_nonneg _)
  refine mul_le_mul_of_nonneg_left ?_ (norm_nonneg _)
  -- Now obtain bound for `f`.
  rw [mul_comm _ (‚Äñx‚Äñ ^ k)]
  rw [mul_comm _ (‚Üë(2 ^ k) : ‚Ñù)]
  simp_rw [schwartzSeminormFamily]
  -- Switch to `(1 + ‚Äñx‚Äñ) ^ k`.
  refine le_trans (mul_le_mul_of_nonneg_right (?_ : ‚Äñx‚Äñ ^ k ‚â§ (1 + ‚Äñx‚Äñ) ^ k) (norm_nonneg _)) ?_
  . refine pow_le_pow_of_le_left ?_ ?_ k
    . exact norm_nonneg x
    . exact le_add_of_nonneg_left zero_le_one
  -- Need to use pair.
  generalize hm : (k, n) = m
  have hk : k = m.1 := by rw [‚Üê hm]
  have hn : n = m.2 := by rw [‚Üê hm]
  rw [hk, hn]
  exact one_add_le_sup_seminorm_apply (Nat.le_refl m.1) (Nat.sub_le m.2 i) f x


lemma exists_hasTemperateGrowth_smul_bound {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g) (k n : ‚Ñï) :
    ‚àÉ (s : Finset (‚Ñï √ó ‚Ñï)) (C : ‚Ñù), 0 ‚â§ C ‚àß ‚àÄ (f : ùì¢(E, F)) (x : E),
      ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n (fun x => g x ‚Ä¢ f x) x‚Äñ ‚â§
      C * s.sup (schwartzSeminormFamily ùïú E F) f := by
  rcases hg with ‚ü®hg_smooth, hg_bound‚ü©

  -- Obtain upper bound that holds for all `0 ‚â§ i ‚â§ n`. Use maximum `k_g` and maximum `C_g`.
  have (m) : ‚àÉ k C, 0 ‚â§ C ‚àß ‚àÄ i ‚àà Finset.range m, ‚àÄ (x : E), ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ ‚â§ C * (1 + ‚Äñx‚Äñ) ^ k
  . induction m with
    | zero => simp; use 0
    | succ m h_ind =>
      specialize hg_bound m
      rcases hg_bound with ‚ü®k_m, C_m, hC_m‚ü©
      rcases h_ind with ‚ü®k_i, C_i, ‚ü®hC_i_nonneg, hC_i‚ü©‚ü©
      refine ‚ü®max k_i k_m, max C_i C_m, ?_‚ü©
      refine And.intro (le_trans hC_i_nonneg (by simp)) ?_
      intro i hi x
      simp [Nat.lt_succ] at hi
      simp at hC_i
      cases lt_or_eq_of_le hi with
      | inl hi =>
        specialize hC_i i hi x
        refine le_trans hC_i ?_
        refine mul_le_mul ?_ (pow_le_pow ?_ ?_) ?_ (le_trans hC_i_nonneg ?_) <;> simp
      | inr hi =>
        rw [hi]
        specialize hC_m x
        refine le_trans hC_m ?_
        refine mul_le_mul ?_ (pow_le_pow ?_ ?_) ?_ (le_trans hC_i_nonneg ?_) <;> simp
  specialize this (n + 1)
  rcases this with ‚ü®k_g, C_g, ‚ü®hC_g_nonneg, hC_g‚ü©‚ü©

  -- Note: Could use `max k k_g` for tighter bound?
  use Finset.Iic (k + k_g, n)
  use 2 ^ (k + k_g) * 2 ^ n * C_g
  norm_num
  simp [hC_g_nonneg]
  intro f x
  refine le_trans (mul_le_mul_of_nonneg_left
    (norm_iteratedFDeriv_smul_le hg_smooth (f.smooth ‚ä§) x (le_top : (n : ‚Ñï‚àû) ‚â§ ‚ä§))
    (by simp : 0 ‚â§ ‚Äñx‚Äñ ^ k)) ?_

  -- Move `‚Äñx‚Äñ ^ k` inside sum and bound each summand.
  rw [Finset.mul_sum]
  suffices : ‚àÄ i ‚àà Finset.range (n + 1),
      ‚Äñx‚Äñ ^ k * (n.choose i * ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ * ‚ÄñiteratedFDeriv ‚Ñù (n - i) f x‚Äñ) ‚â§
      2 ^ (k + k_g) * n.choose i * C_g * (Finset.Iic (k + k_g, n)).sup (schwartzSeminormFamily ùïú E F) f
  . refine le_trans (Finset.sum_le_sum this) ?_
    clear this
    simp [‚Üê Finset.sum_mul, ‚Üê Finset.mul_sum]
    norm_cast
    rw [Nat.sum_range_choose]

  intro i hi
  simp [Nat.lt_succ] at hi hC_g
  -- Eliminate `choose` term.
  rw [mul_comm (‚Äñx‚Äñ ^ k)]
  rw [mul_comm _ (n.choose i : ‚Ñù)]
  simp [mul_assoc, Nat.choose_pos hi]
  -- Replace `‚Äñx‚Äñ` with `1 + ‚Äñx‚Äñ`.
  simp [‚Üê mul_assoc]
  refine le_trans (mul_le_mul_of_nonneg_left (?_ : ‚Äñx‚Äñ ^ k ‚â§ (1 + ‚Äñx‚Äñ) ^ k) ?_) ?_
  . refine pow_le_pow_of_le_left ?_ ?_ k
    . exact norm_nonneg x
    . exact le_add_of_nonneg_left zero_le_one
  . refine mul_nonneg ?_ ?_ <;> exact norm_nonneg _
  -- Bound on `g`.
  simp [mul_assoc]
  refine le_trans (mul_le_mul_of_nonneg_right (hC_g i hi x) ?_) ?_
  . exact mul_nonneg (norm_nonneg _) (by simp)
  -- Eliminate `C_g`.
  simp [‚Üê mul_assoc]
  rw [mul_comm _ C_g]
  simp [mul_assoc]
  refine mul_le_mul_of_nonneg_left ?_ hC_g_nonneg
  -- Merge terms.
  rw [mul_comm _ (_ ^ k)]
  simp [‚Üê mul_assoc]
  rw [‚Üê pow_add]
  rw [add_comm k_g k]
  -- Bound on `f`.
  have : (1 + ‚Äñx‚Äñ) ^ (k + k_g) * ‚ÄñiteratedFDeriv ‚Ñù (n - i) f x‚Äñ ‚â§ _ :=
    one_add_le_sup_seminorm_apply (ùïú := ùïú) (m := (k + k_g, n)) ?_ ?_ f x
    <;> simp
  simp at this
  exact this


/-- Bound the seminorm of `g ‚Ä¢ f` by the seminorm of `f` for `mkCLM`. -/
lemma hasTemperateGrowth_smul_bound'' {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g) (k n : ‚Ñï) {C : ‚Ñù} :
    ‚àÄ (f : ùì¢(E, F)) (x : E),
      ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n (fun x => g x ‚Ä¢ f x) x‚Äñ ‚â§
      (2 ^ k) * C * (Finset.Iic (k, n)).sup (schwartzSeminormFamily ùïú E F) f := by
  intro f x
  refine le_trans (mul_le_mul_of_nonneg_right (?_ : ‚Äñx‚Äñ ^ k ‚â§ (1 + ‚Äñx‚Äñ) ^ k) (norm_nonneg _)) ?_
  . refine pow_le_pow_of_le_left ?_ ?_ k
    . exact norm_nonneg x
    . exact le_add_of_nonneg_left zero_le_one

  rw [‚Üê coeFn_hasTemperateGrowth_smul hg]
  have (k' n' : ‚Ñï) (hk : k' ‚â§ k) (hn : n' ‚â§ n) :=
    one_add_le_sup_seminorm_apply (ùïú := ùïú) (m := (k, n)) hk hn (hasTemperateGrowth_smul hg f) x
  simp at this
  refine le_trans (this k n (by simp) (by simp)) ?_
  simp [mul_assoc]
  -- Is this useful? sup ‚â§ sup...
  -- Need to prove that seminorms of `g ‚Ä¢ f` are bounded by seminorms of `f`...
  sorry


/-- Bound the seminorm of `g ‚Ä¢ f` by the seminorm of `f` for `mkCLM`. -/
lemma exists_hasTemperateGrowth_smul_bound' {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g) (k n : ‚Ñï) :
    ‚àÉ (s : Finset (‚Ñï √ó ‚Ñï)) (C : ‚Ñù), 0 ‚â§ C ‚àß
      ‚àÄ (f : ùì¢(E, F)) (x : E),
        ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n (g ‚Ä¢ (f : E ‚Üí F)) x‚Äñ ‚â§
          C * s.sup (schwartzSeminormFamily ùïú E F) f := by
  use Finset.Iic (k, n)
  -- use ‚Üë(2 ^ k : ‚Ñï) * (‚àë i in Finset.range (n + 1), (n.choose i) * ‚ÄñiteratedFDeriv ‚Ñù i g x‚Äñ)
  sorry


-- TODO: Possible/useful to generalize to `‚ÜíSL[œÉ]` with `ùïú` and `ùïú'`?
def hasTemperateGrowth_smulCLM {g : E ‚Üí ‚Ñù} (hg : Function.HasTemperateGrowth g) :
    ùì¢(E, F) ‚ÜíL[ùïú] ùì¢(E, F) :=
  mkCLM (fun œÜ x => (g ‚Ä¢ œÜ) x)
    (fun œÜ Œ∏ x => by simp)
    (fun a œÜ x => smul_comm (g x) a (œÜ x))
    (fun œÜ => ContDiff.smul hg.1 (œÜ.smooth ‚ä§))
    (fun m => exists_hasTemperateGrowth_smul_bound hg m.1 m.2)


-- TODO: Define CLMs for `Lp_smul` and `HasTemperateGrowth_smul`?

-- def smul_CLM {p : ENNReal} (hp : 1 ‚â§ p) {g : E ‚Üí ùïú} :
--     ùì¢(E, F) ‚ÜíL[ùïú] ùì¢(E, F) where
--   toFun œÜ := fun x => g x ‚Ä¢ œÜ x
--   map_add' := integral_Lp_smul_add hp g
--   map_smul' := integral_Lp_smul_smul g
--   cont := by
--     refine Seminorm.cont_withSeminorms_normedSpace _ (schwartz_withSeminorms ùïú E F) _ ?_
--     simp [Seminorm.le_def]
--     conv => arg 1; intro s; arg 1; intro C; intro œÜ  -- Rename.
--     simp [NNReal.smul_def]
--     sorry


end SchwartzMap


-- TODO: Move to `LpHoelder`.
-- Easier to keep it here for planning; avoids need to rebuild dependency.
namespace Lp

variable {E : Type*} [MeasurableSpace E]
variable {Œº : Measure E}

variable {ùïú : Type*} [NormedField ùïú]
variable {F : Type*} [NormedAddCommGroup F]
-- variable [SMulZeroClass ùïú F] [BoundedSMul ùïú F]

variable {p : ‚Ñù‚â•0‚àû} [hp : Fact (1 ‚â§ p)]
variable {f : Lp ùïú p Œº}

/-- Defines `g ‚Ü¶ ‚à´ x, f x ‚Ä¢ g x` with `f : Lp` and `g : Lq` as a CLM.

TODO: Define as a bilinear CLM?
-/
noncomputable def Lp_smul_CLM {p : ‚Ñù‚â•0‚àû} [hp : Fact (1 ‚â§ p)] (f : Lp ùïú p Œº) :
    Lp ùïú 2 Œº ‚ÜíL[ùïú] Lp ùïú 1 Œº where
  toFun :=

    sorry
  map_add' := sorry
  map_smul' := sorry
  cont := sorry

end Lp


-- -- Plan is to define mapping from `L1` to `L1`,
-- -- then show continuous,
-- -- then transfer to `ùì¢(E, F)` using `ContinuousLinearMap.comp`.
-- section L1

-- variable {Œ± : Type*}
-- variable {E : Type*} [NormedAddCommGroup E]
-- variable {ùïú : Type*} [NormedField ùïú] [NormedSpace ùïú E]

-- lemma memL1_mem‚Ñíp_top_smul [MeasurableSpace Œ±] {g : Œ± ‚Üí ùïú} {Œº : Measure Œ±}
--     (hg : Mem‚Ñíp g ‚ä§ Œº) (f : Lp E 1 Œº) :
--     Mem‚Ñíp (g ‚Ä¢ (f : Œ± ‚Üí E)) 1 Œº := by
--   refine And.intro ?_ ?_
--   . exact AEStronglyMeasurable.smul hg.aestronglyMeasurable (Lp.aestronglyMeasurable f)
--   . have : snorm (g ‚Ä¢ (f : Œ± ‚Üí E)) 1 Œº ‚â§ snorm g ‚àû Œº * snorm f 1 Œº
--     . refine snorm_smul_le_mul_snorm ?_ ?_ (by norm_num)
--       . exact Lp.aestronglyMeasurable f
--       . exact hg.aestronglyMeasurable
--     refine lt_of_le_of_lt this ?_
--     refine ENNReal.mul_lt_top ?_ ?_
--     . exact Mem‚Ñíp.snorm_ne_top hg
--     . exact Lp.snorm_ne_top f

-- lemma memL1_aestronglyMeasurable_smul_of_ae_bound {g : Œ± ‚Üí ùïú} [MeasurableSpace Œ±]
--     {Œº : Measure Œ±}
--     (hg_meas : AEStronglyMeasurable g Œº)
--     {C : ‚Ñù} (hg_bound : ‚àÄ·µê x ‚àÇŒº, ‚Äñg x‚Äñ ‚â§ C)
--     (f : Lp E 1 Œº) :
--     Mem‚Ñíp (g ‚Ä¢ (f : Œ± ‚Üí E)) 1 Œº := by
--   refine memL1_mem‚Ñíp_top_smul ?_ f
--   exact mem‚Ñíp_top_of_bound hg_meas C hg_bound

-- lemma memL1_continuous_smul_of_bound {g : Œ± ‚Üí ùïú} [MeasurableSpace Œ±]
--     [TopologicalSpace Œ±] [OpensMeasurableSpace Œ±] [SecondCountableTopologyEither Œ± ùïú]
--     (hg_cont : Continuous g)
--     {C : ‚Ñù} (hg_bound : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ C)
--     {Œº : Measure Œ±}
--     (f : Lp E 1 Œº) :
--     Mem‚Ñíp (g ‚Ä¢ (f : Œ± ‚Üí E)) 1 Œº :=
--   memL1_aestronglyMeasurable_smul_of_ae_bound
--     hg_cont.aestronglyMeasurable (ae_of_all Œº hg_bound) f

-- -- Can show that function is ae `< ‚àû`, but not `‚â§ C`.
-- lemma Mem‚Ñíp_nnreal_ae_lt_top [MeasurableSpace Œ±] {p : NNReal} (hp : p ‚â† 0) {f : Œ± ‚Üí E}
--     (Œº : Measure Œ± := by volume_tac)
--     (hf : Mem‚Ñíp f p Œº) :
--     ‚àÄ·µê x ‚àÇŒº, (‚Äñf x‚Äñ‚Çä : ENNReal) < ‚ä§ := by
--   suffices : ‚àÄ·µê x ‚àÇŒº, (‚Äñf x‚Äñ‚Çä ^ (p : ‚Ñù) : ENNReal) < ‚ä§
--   . exact Filter.Eventually.congr this (by simp)
--   refine ae_lt_top' ?_ ?_
--   . refine AEMeasurable.coe_nnreal_ennreal (AEMeasurable.pow_const ?_ _)
--     exact hf.aestronglyMeasurable.nnnorm.aemeasurable
--   rw [‚Üê lt_top_iff_ne_top]
--   rcases hf with ‚ü®_, hf‚ü©
--   rw [snorm_lt_top_iff_lintegral_rpow_nnnorm_lt_top] at hf
--   rotate_left
--   . norm_cast
--   . simp
--   simp at hf
--   simp_rw [ENNReal.coe_rpow_of_nonneg _ (NNReal.coe_nonneg p)] at hf
--   exact hf

-- -- TODO: Are there conditions under which we can obtain `Lp _ ‚àû` from `Lp _ p`?
-- -- Would it help to assume `continuous` or `volume`?
-- -- Mainly need to show that function doesn't go to infinity on a set of positive measure?
-- lemma mem‚Ñíp_top_of_mem‚Ñíp_volume [MeasureSpace Œ±] {p : ENNReal} {g : Œ± ‚Üí ùïú}
--     (hg : Mem‚Ñíp g p) (hp : 1 ‚â§ p) : Mem‚Ñíp g ‚ä§ := by
--   cases p with
--   | none => exact hg
--   | some p =>
--     simp at hg hp
--     have hp_pos : 0 < p := lt_of_lt_of_le zero_lt_one hp
--     rcases hg with ‚ü®hg_meas, hg_bound‚ü©
--     refine And.intro hg_meas ?_
--     simp
--     simp [snorm, hp_pos.ne', snorm'] at hg_bound
--     suffices : ‚àÉ C, ‚àÄ·µê (x : Œ±) ‚àÇvolume, ‚Äñg x‚Äñ ‚â§ C
--     . rcases this with ‚ü®C, hC‚ü©
--       exact snormEssSup_lt_top_of_ae_bound hC
--     sorry

-- -- lemma memL1_integralAgainst_mem‚Ñíp_nnreal [TopologicalSpace Œ±] [MeasureSpace Œ±]
-- --     {p : NNReal} (hp : 1 ‚â§ p)
-- --     {g : Œ± ‚Üí ùïú} (hg : Mem‚Ñíp g p)
-- --     (f : Lp E 1) :
-- --     Mem‚Ñíp (g ‚Ä¢ (f : Œ± ‚Üí E)) 1 := by
-- --   -- suffices : ‚àÉ C, ‚àÄ·µê (x : Œ±) ‚àÇvolume, ‚Äñg x‚Äñ ‚â§ C
-- --   -- . rcases this with ‚ü®C, hC‚ü©
-- --   --   exact memL1_integralAgainst_bound volume hg.aestronglyMeasurable hC f
-- --   refine memL1_integralAgainstMem‚Ñíp_top ?_ f
-- --   exact mem‚Ñíp_top_of_mem‚Ñíp_volume hg (by norm_cast)

-- end L1


-- namespace SchwartzMap

-- variable {ùïú : Type*} [NontriviallyNormedField ùïú]
-- variable {E F : Type*}
-- variable [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
-- variable [mE : MeasureSpace E] [FiniteDimensional ‚Ñù E] [BorelSpace E] [mE.volume.IsAddHaarMeasure]
-- variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
-- variable [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F]

-- -- Define specifically for `ùì¢(E, F)` since Schwartz maps are in `Lp` for any `p`.
-- -- TODO: Possible to generalize to `L1` using equivalence to functions on `[0, 1]`?
-- lemma memL1_mem‚Ñíp_smul {p : ENNReal} (hp : 1 ‚â§ p)
--     {g : E ‚Üí ùïú} (hg : Mem‚Ñíp g p) (f : ùì¢(E, F)) :
--     Mem‚Ñíp (g ‚Ä¢ (f : E ‚Üí F)) 1 := by
--   refine And.intro ?_ ?_
--   . exact AEStronglyMeasurable.smul hg.aestronglyMeasurable f.continuous.aestronglyMeasurable
--   . -- 1/p + 1/q = 1; q = p / (p-1) = 1 / (1 - 1/p)
--     generalize hq : (1 - p‚Åª¬π)‚Åª¬π = q
--     -- have hq' : 1 ‚â§ q
--     -- . simp [‚Üê hq]
--     have hpq : 1/1 = 1/p + 1/q
--     . simp [‚Üê hq, hp]
--     have : snorm (g ‚Ä¢ (f : E ‚Üí F)) 1 volume ‚â§ snorm g p volume * snorm f q volume
--     . refine snorm_smul_le_mul_snorm ?_ ?_ hpq
--       . exact f.continuous.aestronglyMeasurable
--       . exact hg.aestronglyMeasurable
--     refine lt_of_le_of_lt this ?_
--     refine ENNReal.mul_lt_top ?_ ?_
--     . exact Mem‚Ñíp.snorm_ne_top hg
--     . rw [‚Üê lt_top_iff_ne_top]
--       exact snorm_lt_top f


-- noncomputable def integralAgainstMem‚ÑípLM
--     {p : ENNReal} (hp : 1 ‚â§ p) {g : E ‚Üí ùïú} (hg : Mem‚Ñíp g p) :
--     ùì¢(E, F) ‚Üí‚Çó[ùïú] F where
--   -- toFun œÜ := L1.integralCLM (Mem‚Ñíp.toLp _ (memL1_mem‚Ñíp_smul hp hg œÜ))
--   toFun œÜ := L1.integral (Mem‚Ñíp.toLp _ (memL1_mem‚Ñíp_smul hp hg œÜ))
--   map_add' œÜ œÜ' := by
--     simp
--     sorry
--   map_smul' d œÜ := by
--     simp
--     sorry

-- lemma integralAgainstMem‚ÑípLM_apply {p : ENNReal} (hp : 1 ‚â§ p)
--     {g : E ‚Üí ùïú} (hg : Mem‚Ñíp g p) (œÜ : ùì¢(E, F)) :
--     integralAgainstMem‚ÑípLM hp hg œÜ = ‚à´ (x : E), g x ‚Ä¢ œÜ x := by
--   simp [integralAgainstMem‚ÑípLM]
--   -- rw [‚Üê integral_eq]
--   -- simp [L1.integral_eq_integral]
--   -- simp [Mem‚Ñíp.coeFn_toLp]
--   sorry


-- /- Helper for `integralAgainstContinuousCLM`. -/
-- noncomputable def integralAgainstContinuousLM [CompleteSpace F] {g : E ‚Üí ùïú}
--     (hg_meas : MeasureTheory.AEStronglyMeasurable g volume)
--     (hg_bdd : essSup (fun x => (‚Äñg x‚Äñ‚Çä : ENNReal)) volume ‚â† ‚ä§) :
--     ùì¢(E, F) ‚Üí‚Çó[ùïú] F where
--   toFun œÜ := ‚à´ (x : E), g x ‚Ä¢ œÜ x
--   map_add' œÜ œÜ' := by
--     simp
--     rw [integral_add]
--     . refine Integrable.essSup_smul œÜ.integrable hg_meas hg_bdd
--     . refine Integrable.essSup_smul œÜ'.integrable hg_meas hg_bdd
--   map_smul' d œÜ := by
--     simp
--     rw [‚Üê integral_smul]
--     simp_rw [smul_comm d]

-- /- Integration against a continuous function as a CLM. -/
-- noncomputable def integralAgainstContinuousCLM [CompleteSpace F] (g : E ‚Üí ùïú)
--     (hg_meas : MeasureTheory.AEStronglyMeasurable g volume)
--     (hg_bdd : essSup (fun x => (‚Äñg x‚Äñ‚Çä : ENNReal)) volume ‚â† ‚ä§) :
--     ùì¢(E, F) ‚ÜíL[ùïú] F where
--   toLinearMap := integralAgainstContinuousLM g hg_meas hg_bdd
--   cont := by
--     simp
--     sorry
--   -- cont := by
--   --   simp
--   --   refine Continuous.comp _ (toL1_CLM ùïú)
--   --   refine Continuous.comp _ (Lp.continuous_inner_left _)
--   --   exact Continuous.comp _ (Continuous.prod_map Continuous.id Continuous.id)

-- /- Integration against a measure as a CLM. -/
-- noncomputable def integralAgainstMeasureLM [CompleteSpace F] (Œº : Measure E) :
--     ùì¢(E, F) ‚Üí‚Çó[ùïú] F where
--   toFun œÜ := ‚à´ (x : E), œÜ x ‚àÇŒº
--   map_add' œÜ œÜ' := by
--     simp
--     rw [integral_add]
--     . sorry
--     . sorry
--   map_smul' d œÜ := by
--     simp
--     rw [‚Üê integral_smul]
--   -- cont := by
--   --   simp
--   --   refine Continuous.comp _ (toL1_CLM ùïú)
--   --   refine Continuous.comp _ (Lp.continuous_inner_left _)
--   --   exact Continuous.comp _ (Continuous.prod_map Continuous.id Continuous.id)

-- -- TODO: Define a CLM by integration with a vector measure.
-- -- noncomputable def integral_vectorMeasure_CLM [CompleteSpace F] (Œº : VectorMeasure E ùïú) :
-- --     ùì¢(E, F) ‚ÜíL[ùïú] F where

-- end SchwartzMap
